

################################################################################
# Общие параметры
################################################################################

# Тип окончания строки.
#
# Type: lf/crlf/cr/auto
# Default: auto 
newlines = auto

# Оригинальный размер табуляций во входном файле.
#
# Type: unsigned  1  32
# Default: 8 
input_tab_size = 8

# Размер табуляций для выходного файла (только при `align_with_tabs=true`).
#
# Type: unsigned  1  32
# Default: 8 
output_tab_size = 8

# ASCII код символа экранирования, обычно 92 (\) или (для Pawn) 94 (^).
#
# Type: unsigned  0  255
# Default: 92 
string_escape_char = 92

# Альтернативный экранирующий символ (обычно используется только для Pawn).
# Работает только непосредственно перед символом кавычки.
#
# Type: unsigned  0  255
# Default: 0 
string_escape_char2 = 0

# Заменить символы табуляции, встречающиеся в строковых литералах, на управляющую
# последовательность \t.
#
# Type: true/false
# Default: false 
string_replace_tab_chars = true

# Разрешить интерпретировать >=' и '>>=' как часть шаблона в коде типа `void
# f(list<list<B>>=val);`
# Если `true`, может сломать `assert(x<0 && y>=3)`.
# Усовершенствования в обнаружении шаблонов могут сделать эту опцию устаревшей.
#
# Type: true/false
# Default: false 
tok_split_gte = false

# Отключить форматирование строк, заканчивающихся NL_CONT ('\n') (например,
# многострочные макросы).
#
# Type: true/false
# Default: false 
disable_processing_nl_cont = false

# Задать маркер, используемый в комментариях, чтобы запретить обработку части
# файла.
#
# Type: string
# Default: UNCRUSTIFY_OFF_TEXT 
disable_processing_cmt = "UNCRUSTIFY_OFF_TEXT"


# Задать маркер, используемый в комментариях для (повторного) включения обработки
# файла.
#
# Type: string
# Default: UNCRUSTIFY_ON_TEXT 
enable_processing_cmt = "UNCRUSTIFY_ON_TEXT"


# Включить разбор диграфов.
#
# Type: true/false
# Default: false 
enable_digraphs = false

# Опция, позволяющая интерпретировать строки `disable_processing_cmt` и
# `enable_processing_cmt`, если они указаны, как регулярные выражения ECMAScript.
# Если `true`, то для отключения/включения обработки в комментариях будет
# выполняться regex-поиск в соответствии с указанными шаблонами.
#
# Type: true/false
# Default: false 
processing_cmt_as_regex = false

# Добавить или убрать маркер UTF-8 BOM (рекомендуется `remove`).
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
utf8_bom = ignore

# Если файл содержит байты со значениями от 128 до 255, но не UTF-8, то результат
# выводится как UTF-8.
#
# Type: true/false
# Default: false 
utf8_byte = false

# Принудительная кодировка на выходе в UTF-8.
#
# Type: true/false
# Default: false 
utf8_force = false


################################################################################
# Расстановка пробелов
################################################################################

# Добавить или убрать пробел вокруг символов операторов, не относящихся к
# присваиванию (`+`, `/`, `%`, `<<` и так далее).
# `x=x·+·5·/·y;`
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_arith = force

# Добавить или убрать пробел вокруг символов арифметических операторов `+` и `-`.
# `x=x·+·5/y;`
#
# Переопределяет `sp_arith`.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_arith_additive = ignore

# Добавить или убрать пробел вокруг символов операторов c  присваиванием (`=`,
# `+=`, и тому подобное).
# `x·+=·7;`
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_assign = force

# Добавить или убрать пробел вокруг '=' в спецификации захвата лямбды в C++11.
# `auto d = [·=·](int *a, Something & b){std::cout << "blah: " << *a;};`
#
# Переопределяет `sp_assign`.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_cpp_lambda_assign = remove

# Добавить или убрать пробел после спецификации захвата лямбды C++11, когда
# присутствует список аргументов
# `auto d = [=]·(int *a, Something & b){std::cout << "blah: " << *a;};`
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_cpp_lambda_square_paren = remove

# Добавить или убрать пробел после спецификации захвата лямбды C++11 без списка
# аргументов
# `auto d = []·{return 5;};`
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_cpp_lambda_square_brace = force

# Добавить или убрать пробел после открывающей скобки и перед закрывающей скобкой
# в списке аргументов лямбды C++11
# `auto d = [=](·int *a, Something & b·){std::cout << "blah: " << *a;};`
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_cpp_lambda_argument_list = remove

# Добавить или убрать пробел после списка аргументов лямбды C++11
# `auto d = [=](int *a, Something & b)·{std::cout << "blah: " << *a;};`
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_cpp_lambda_paren_brace = force

# Добавить или убрать пробел между телом лямбды и ее оператором вызова немедленно
# вызываемой лямбды.
# `auto d = [=](int *a, Something & b){std::cout << "blah: " << *a;}·(a, b);`
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_cpp_lambda_fparen = remove

# Добавить или убрать пробел вокруг присваивания '=' в прототипе.
# `Foo( unsigned int boo·=·999 );`
#
# Если установлено `ignore`, использует `sp_assign`.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_assign_default = ignore

# Добавить или убрать пробел перед символами операторов  присваивания (`=`, `+=`,
# и тому подобное).
# `x·=5; y·+=7;`
#
# Переопределяет `sp_assign`.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_before_assign = ignore

# Добавить или убрать пробел после символов операторов  присваивания (`=`, `+=`, и
# тому подобное).
# `x=·5; y+=·7;`
#
# Переопределяет `sp_assign`.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_after_assign = ignore

# Добавить или убрать пробел в 'enum {'.
#
# Type: ignore / add / remove / force / not_defined
# Default: add 
sp_enum_brace = add

# (ObjC) Добавить или убрать пробел в 'NS_ENUM ('.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_enum_paren = ignore

# Добавить или убрать пробел вокруг присваивания `=` в enum.
# `enum {
# E11·=·0,
# E12·=·1,
# E13·=·2
# };`
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_enum_assign = force

# Добавить или убрать пробел перед присваивания '=' в enum.
# `enum {
# E11·=0,
# E12·=1,
# E13·=2
# };`
#
# Переопределяет `sp_enum_assign`.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_enum_before_assign = ignore

# Добавить или убрать пробел после присваивания '=' в enum.
# `enum {
# E11=·0,
# E12=·1,
# E13=·2
# };`
#
# Переопределяет `sp_enum_assign`.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_enum_after_assign = ignore

# Добавить или убрать пробел вокруг присваивания ':' в enum.
# `enum class form·:·int{one, two};`
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_enum_colon = force

# Добавить или убрать пробел вокруг препроцессорной комманды конкатенации `##`.
# `#define inline(i) inline_·##·i`
#
# Type: ignore / add / remove / force / not_defined
# Default: add 
sp_pp_concat = force

# Добавить или убрать пробела после оператора строчной обработки препроцессора
# `#`.
# Также влияет на оператор `#@`.
# `#define WARN_IF(EXP) do { if (EXP) fprintf (stderr, "Warning: " #·EXP "\n"); }
# \`
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_pp_stringify = force

# Добавить или убрать пробел перед строковым оператором препроцессора `#`
# `#define WARN_IF(EXP) do { if (EXP) fprintf (stderr, "Warning: "·#EXP "\n"); }
# \`
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_before_pp_stringify = ignore

# Добавить или убрать пробел вокруг логических операторов `&&` и `||`.
# `assert(y <0·&&·z> 2);
# inline decltype(auto) Invoke(Fun·&&·f, Args·&&·... args); // !`
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_bool = force

# Добавить или убрать пробел вокруг операторов сравнения `<`, `>`, `==`, и т.д.
# `for (i = 0; i·<·5; i++) bar(i);`
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_compare = force

# Добавить или убрать пробел внутри скобок `(` и `)`.
# f(const_cast<const Args*>(·&args·)...);
# const int size = sizeof...(·args·) + 2;
# typedef void (*func)();
# typedef void (·__stdcall *func·)();
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_inside_paren = remove

# Добавить или убрать пробел между вложенными скобками
# `__attribute__(·(visibility ("default")·)·) int* i;`
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_paren_paren = force

# Добавить или убрать пробел между соседними скобками
# `typedef void (__stdcall *func)·();`
# `std::forward<Fun>(f)·(std::forward<Args>(args)...);`
# `STDMETHOD(GetValues)·(BSTR bsName, REFDATA** pData);`
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_cparen_oparen = remove

# Балансировать ли пробелы внутри вложенных скобок.
#
# Type: true/false
# Default: false 
sp_balance_nested_parens = false

# Добавить или убрать пробел между `)` и `{`.
# `void f()noexcept()·{}`
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_paren_brace = force

# Добавить или убрать пробел между вложенными фигурными скобками, т.е. '{{' vs
# '{·{'.
# `int d = int{int{}·}; std::vector<some_type> c = {·{}, {}·};`
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_brace_brace = force

# Добавить или убрать пробел перед символом указателя `*`.
# `static void indent_comment(chunk_t·*pc, int col);`
# `chunk_t·*pc;`
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_before_ptr_star = force

# Добавляет или удаляет пробел перед символом указателя `*`, за которой не следует
# имя переменной.
# Если установлено значение ignore, вместо него используется `sp_before_ptr_star`.
# `int·*X(int *i, int ·*)`
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_before_unnamed_ptr_star = ignore

# Добавить или убрать пробел перед символами указателя `*`
# `int·***a;`
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_between_ptr_star = force

# Добавить или убрать пробел после символа указателя `*`, если за ним следует
# слово.
# `int***·a;`
#
# Переопределяет `sp_type_func`.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_after_ptr_star = remove

# (CLI.NET) Добавить или убрать пробел после символа указателя '^', если за ним
# следует слово.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_after_ptr_block_caret = ignore

# Добавить или убрать пробел после символа указателя `*`, если за ним следует
# квалификатор.
# `int * const·i;int *·static i;`
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_after_ptr_star_qualifier = force

# Добавить или убрать пробел после символа указателя `*`, если за ней следует
# прототип функции или определение функции.
# `int *·X(int *i, int *);`
#
# Переопределяет `sp_after_ptr_star` и `sp_type_func`.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_after_ptr_star_func = remove

# Добавить или убрать пробел после символа указателя `*` в конце возврата
# прототипа функции или определения функции.
# static auto Func1(Model *model) -> Color*;
# static auto Func1(Model *model) -> Color*·{ return nullptr;}
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_after_ptr_star_trailing = ignore

# Добавить или убрать пробел между символом указателя `*` и именем переменной в
# определении указателя функции.
# void (*·fun_ptr)(int) = &fun;
# typedef void (*foo)(void);
# void (*·foo)(void);
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_ptr_star_func_var = remove

# Добавить или убрать пробел между символом указателя `*` и именем типа в
# определении типа указателя функции.
# typedef void (*·foo)(void);
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_ptr_star_func_type = remove

# Добавить или убрать пробел после звезды указателя '*', если за ней следует
# открытая скобка
# typedef std::vector<string *> *·(*   Finder )(std::string *);
# typedef const char *·(*somefunc_t)(void *barstool);
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_ptr_star_paren = force

# Добавить или убрать пробел перед символом указателя `*`, если за ней следует
# прототип функции или определение функции.
# `int·*X(int *i, int *);`
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_before_ptr_star_func = force

# Добавить или убрать пробел перед символом указателя '*' в конце возврата
# прототипа функции или определения функции.
# static auto Func1(Model *model) -> Color·*;
# static auto Func1(Model *model) -> Color·*{ return nullptr;}
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_before_ptr_star_trailing = ignore

# Добавить или убрать пробел перед символом ссылки `&`.
# int MyFunc(std::string·& s, char *);
# const Foo & Foo::operator ==(Foo·& me);
# const MyType·& t = getSomewhere();
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_before_byref = force

# Добавляет или удаляет пробел перед знаком ссылки `&`, за которым не следует имя
# переменной.
# Если установлено значение ignore, вместо него используется `sp_before_byref`.
# T MemberFunction(T const·&);
# D2(D2·&&) = delete;
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_before_unnamed_byref = force

# Добавить или убрать пробел после символа ссылки '&', если за ним следует слово.
# typedef int &·MY_INTR;
# CFoo&·fref;
# TYPE_EXPORT method5(int&·a);
#
# Переопределяет `sp_type_func`.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_after_byref = remove

# Добавить или убрать пробел после знака ссылки '&', если за ним следует прототип
# функции или определение функции.
# D1&·operator=(const D1 &) = delete;
# std::vector<int> &·bar();
#
# Переопределяет `sp_after_byref` и `sp_type_func`.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_after_byref_func = remove

# Добавить или убрать пробел перед ссылочным знаком '&', если за ним следует
# прототип функции или определение функции.
# D1·&operator=(const D1 &) = delete;
# std::vector<int>·&bar();
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_before_byref_func = force

# Добавить или убрать пробел после знака ссылки '&', если за ним следует
# открывающая функция.
# char&·(*)()
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_byref_paren = add

# Добавить или убрать пробел между типом и словом. В случаях, когда полное
# удаление пробелов будет синтаксической ошибкой, значение `remove`
# рассматривается так же, как `force`.
# enum class form:int·{one, two};
# struct Tuple·{};
# class X·: public Mixins{};
# using Foo = std::function<void·(const bool)>;
# ~D2() override·= default;
# void·(* foo)(void);
# virtual int getA() const·{};
# friend void·::test::swap< >(future< T > &, future< T > &);
#
# Это также влияет на некоторые другие случаи пробела после типа, которые не
# покрываются другими опциями; например, между возвращаемым типом и скобкой
# аргумента шаблона типа функции, между типом и скобкой параметра массива, или
# между 'decltype(...)' и следующим словом.
#
# Type: ignore / add / remove / force / not_defined
# Default: force 
sp_after_type = force

# Добавить или убрать пробел между 'decltype(...)' и словом, скобкой или вызовом
# функции.
# inline decltype(auto)·Invoke(Fun&& f, Args&&... args)
# return decltype(x)·{x} & 2;
# decltype  (x)·z = 5;
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_after_decltype = force

# (D) Добавить или убрать пробел перед скобкой ( в D-конструкторе `template Foo·(`
# и `class Foo·(`.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_before_template_paren = ignore

# Добавить или убрать пробел между `template` и `<`.
# Если установлено значение `ignore`, используется `sp_before_angle`.
# template·<typename ...> struct Tuple {};
# template·<>struct AClass<float>{};
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_template_angle = remove

# Добавить или убрать пробел перед `<`.
# template·<typename ...> struct Tuple {};
# template·<>struct AClass<float>{};
# Tuple·<> t0;
# x = reinterpret_cast·< ::Symbol*>();
# x=a<b;
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_before_angle = remove

# Добавить или убрать пробел внутри угловых скобок `<` и `>`.
# Tuple<·0·> t3;
# const_cast<·const Args*·>(x);
# template<>template<>struct AClass<·float·>::Inner<·int·>{};
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_inside_angle = remove

# Добавить или убрать пробел внутри `<>`.
# template<·>template<·>struct AClass<float>::Inner<int>{}
# Tuple<·> t0;
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_inside_angle_empty = remove

# Добавить или убрать пробел между '>' и ':'.
# `template< >struct Bar< false >·: Foo{};`
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_angle_colon = ignore

# Добавить или убрать пробел после `>`.
# typedef Tuple<Pair<Args1, Args2>·...> type;
# template< >struct Bar< false >·: Foo
# int bar(foo<int>·);
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_after_angle = force

# Добавить или убрать пробел между `>` и `(`
# `new List<byte>·(foo);`
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_angle_paren = remove

# Добавить или убрать пробел между `>` и `()`
# `new List<byte>·();`
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_angle_paren_empty = remove

# Добавить или убрать пробел между `>` и словом
# `List<byte>·m;`
# `template <typename T>·static ...`
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_angle_word = force

# Добавить или убрать пробел между `>` и `>` в `>>` (вложенные шаблоны).
# `foo<bar<int>·>`
#
# Type: ignore / add / remove / force / not_defined
# Default: add 
sp_angle_shift = ignore

# (C++11) Разрешить удаление пробела между `>>` в `foo<bar<int>·>`
# Обратите внимание что `sp_angle_shift` не может удалить пробел без этой опции.
#
# Type: true/false
# Default: false 
sp_permit_cpp11_shift = false

# Добавить или убрать пробел перед `(` управляющих операторов (`if`, `for`,
# `switch`,
# `while` и т.д.).
# `if·(x>5)return;`
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_before_sparen = force

# Добавить или убрать пробел внутри `(` и `)` управляющих операторов, кроме `for`.
# switch (·a·) {};
# if (·x!=2·) {};
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_inside_sparen = remove

# Добавить или убрать пробел после `(` в управляющих операторах, отличных от
# `for`.
# `if(·x>5) return;`
#
# Переопределяет `sp_inside_sparen`.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_inside_sparen_open = remove

# Добавить или убрать пробел перед `)` в управляющих операторах, отличных от
# `for`.
# `if(x>5·)return;`
#
# Переопределяет `sp_inside_sparen`.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_inside_sparen_close = remove

# Добавить или убрать пробел внутри `(` и `)` в операторах `for`.
# for (·i = 0; i< 5; i++·) bar(i);
# for (·auto &it : *list·) {}
# Q_FOREACH(·QString partName, lParts·) {}
# for(;;) {i++;}
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_inside_for = ignore

# Добавить или убрать пробел после `(` в операторах `for`.
# for (·i = 0; i < 5; i++) bar(i);
# for (·auto &it : *list) {}
# Q_FOREACH(·QString partName, lParts) {}
# for(;;) {i++;}
#
# Переопределяет `sp_inside_for`.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_inside_for_open = ignore

# Добавить или убрать пробел перед `)` в операторах `for`.
# for (i = 0; i < 5; i++·) bar(i);
# for (auto &it : *list·) {}
# Q_FOREACH(QString partName, lParts·) {}
# for(;;) {i++;}
#
# Переопределяет `sp_inside_for`.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_inside_for_close = ignore

# Добавить или убрать пробел между `((` или `))` управляющих утверждений.
# if (!(x)·) *(volatile int *)0 = 1;
# if (·(frm.pse[frm.pse_tos].type == CT_CASE) &&
# ((pc->type == CT_BRACE_CLOSE) ||
# (pc->type == CT_CASE))·)
# {indent_pse_pop(frm, pc);}
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_sparen_paren = ignore

# Добавить или убрать пробел после `)` в управляющих конструкциях.
# if(x)·[[likely]] {}
# if(x){}
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_after_sparen = force

# Добавить или убрать пробел между `)` и `{` в управляющих операторах.
# `if(x)·{}`
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_sparen_brace = force

# Добавить или убрать пробел между `do` и `{`.
# `do·{x++;}while(true);`
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_do_brace_open = force

# Добавить или убрать пробел между `}` и `while`.
# `do{x++;}·while(x<5);`
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_brace_close_while = force

# Добавляет или удаляет пробел между `while` и `(`. Переопределяет
# `sp_before_sparen`.
# `do { amime3(); } while·(false);`
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_while_paren_open = force

# (D) Добавить или убрать пробел между `invariant` и `(`.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_invariant_paren = ignore

# (D) Добавить или убрать пробел после ')' в 'invariant (C) c'.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_after_invariant_paren = ignore

# Добавить или убрать пробел перед пустым оператором ';' в `if`, `for` и `while`.
# `while(x++)·;`
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_special_semi = ignore

# Добавить или убрать пробел перед `;`.
# for(;;){i++·;}
# if(x) i++·;
# enum class form:int{one, two}·;
#
# Type: ignore / add / remove / force / not_defined
# Default: remove 
sp_before_semi = remove

# Добавить или убрать пробел перед `;` в непустом выражении `for`.
# for(;;){i++;}
# for(i=0·;;i++){}
# for(i=0·;i<10·;i++){}
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_before_semi_for = remove

# Добавить или убрать пробел перед точкой с запятой пустой левой части оператора
# `for`
# `for (·; ; )`
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_before_semi_for_empty = force

# Добавить или убрать пробел между точками с запятой в пустой средней части
# оператора `for`
# `for ( ; · ; )`
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_between_semi_for_empty = ignore

# Добавить или убрать пробел после `;`, за исключением случаев, когда после этого
# следует комментарий.
# struct foo { int a;·char *b };
# void bar(); // this one should align with the previous line
# if (auto const& r(ric);·r > 0){       }
#
# Type: ignore / add / remove / force / not_defined
# Default: add 
sp_after_semi = force

# Добавить или убрать пробел после `;` в непустых заявлениях `for`
# for(;;){i++;}
# for(i=0;·;i++){}
# for(i=0;·i<10;·i++){}
#
# Type: ignore / add / remove / force / not_defined
# Default: force 
sp_after_semi_for = force

# Добавить или убрать пробел после точки с запятой в пустой части оператора for
# `for ( ; ; ·){}`
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_after_semi_for_empty = remove

# Добавить или убрать пробел перед `[` (кроме `[]`).
# a=b·[i];
# x·[i]=b·[i];
# char[] c=new char[15];
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_before_square = remove

# Добавить или убрать пробел перед `[` в определении переменной.
# int res·[size] = {1, args ..., 2};
# x[i]=b[i];
#
# Type: ignore / add / remove / force / not_defined
# Default: remove 
sp_before_vardef_square = remove

# Добавить или убрать пробел перед `[` для ассемблерного блока.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_before_square_asm_block = ignore

# Добавить или убрать пробел перед `[]`.
# char·[] c=new char[15];
# int main(int argc, char *argv·[])
# int a0·[]·[] = {{  1  }};
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_before_squares = remove

# Добавить или убрать пробел перед распаковкой структуры C++17.
# auto const·[iterator, inserted]{ super_type::insert(ioFileReference) }
# buf = new unsigned char·[1024];
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_cpp_before_struct_binding = remove

# Добавить или убрать пробел внутри непустого `[` и `]`.
# a=b[·i·];
# x[·i·]=b[·i·];
# char[] c=new char[·15·];
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_inside_square = remove

# Добавить или убрать пробел внутри '[]'.
# `char[·]s='test';`
# `void d(double[·]x);`
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_inside_square_empty = ignore

# (OC) Добавить или убрать пробел внутри непустого боксового массива Objective-C
# '@[' и ']'. <br>
# Если установлено значение ignore, используется sp_inside_square.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_inside_square_oc_array = ignore

# Добавить или убрать пробел после запятой, т.е. `a,b` против `a,·b`.
# int head,·bar;
# int printy(...,·const char* fmt);
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_after_comma = force

# Добавить или убрать пробел перед запятой, т.е. `a,b` против `a·,b`.
# int head·,bar;
# int printy(...·,const char* fmt);
#
# Type: ignore / add / remove / force / not_defined
# Default: remove 
sp_before_comma = remove

# (C#) Добавить или убрать пробел между ',' и ']' в многомерных массивах типа
# 'int[,,]'.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_after_mdatype_commas = ignore

# Добавить или убрать пробел между '[' и ',' в многомерных массивах типа
# 'int[,,]'.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_before_mdatype_commas = ignore

# (C#) Добавить или убрать пробел между ',' в многомерных массивах типа 'int[,,]'.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_between_mdatype_commas = ignore

# Добавить или убрать пробел между открывающей скобкой и запятой
# `a(·, 1);`
#
# Type: ignore / add / remove / force / not_defined
# Default: force 
sp_paren_comma = ignore

# (C11) Добавить или убрать пробел между типом и `:`.
# #define IS_UNSIGNED(t) _Generic((t),  uint8_t·: true)
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_type_colon = ignore

# Добавить или убрать пробел после переменной `...`, если перед ней стоит
# непунктуатор.
# Значение `REMOVE` будет отменено значением `FORCE`
# `switch(i){case 1...·2:`
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_after_ellipsis = ignore

# Добавить или убрать пробел перед переменной `...`, если перед ней стоит
# непунктуатор.
# Значение `REMOVE` будет отменено значением `FORCE`
# `switch(i){case 1·...2:`
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_before_ellipsis = remove

# Добавить или убрать пробел между типом и `...`.
# #define LOG_FMT (sev, args·...)
# template<int i, int·... Indexes, typename IdxHolder, typename·... Elements>
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_type_ellipsis = ignore

# Добавить или убрать пробел между `*` и `...`
# template<class R, typename ...Args>
# void call1p(R(*fp)(Args*·...));
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_ptr_type_ellipsis = ignore

# Добавить или убрать пробел между `)` и `...`
# `#define LOG_FMT (sev, args...·)`
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_paren_ellipsis = ignore

# Добавить или убрать пробел между `&&` и `...`
# template<class R, typename ...Args>
# void call1r(R(*fp)(Args&&·...));
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_byref_ellipsis = ignore

# Добавить или убрать пробел между `)` и классификатором, таким как `const`.
# `float fabs(fload x)·const`
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_paren_qualifier = force

# Добавить или убрать пробел между `)` и `noexcept`
# `float fabs(fload x)·noexept`
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_paren_noexcept = ignore

# Добавить или убрать пробел после двоеточия класса.
# `class my_class:·baseclass1{}`
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_after_class_colon = force

# Добавить или удалять пробел перед двоеточием класса.
# `class my_class·:baseclass1{}`
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_before_class_colon = force

# Добавить или удалять пробел после двоеточия конструктора класса.
# `my_class::my_class(int b):·x(b){...}`
#
# Type: ignore / add / remove / force / not_defined
# Default: add 
sp_after_constr_colon = force

# Добавить или удалять пробел перед двоеточием конструктора класса.
# `my_class::my_class(int b)·:x(b){...}`
#
# Type: ignore / add / remove / force / not_defined
# Default: add 
sp_before_constr_colon = ignore

# Добавить или удалять пробел перед двоеточием в case.
# `case 1·:`
#
# Type: ignore / add / remove / force / not_defined
# Default: remove 
sp_before_case_colon = remove

# Добавить или убрать пробел между `operator` и знаком оператора.
# `T operator·+(T v)`
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_after_operator = remove

# Добавить или убрать пробел между символом оператора и открывающей скобкой
# `operator ++·(`
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_after_operator_sym = remove

# Отменяет `sp_after_operator_sym`, когда оператор не имеет аргументов
# `operator *()`.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_after_operator_sym_empty = ignore

# Добавить или убрать пробел после C/D каста
# cast(int)·a
# (int)·a
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_after_cast = remove

# Добавить или убрать пробелов внутри круглых скобок в преобразовнии типов.
# `(·int·)a`
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_inside_paren_cast = remove

# Добавить или убрать пробел между типом и открывающей круглой скобкой при
# приведении в C++
# `int·(exp)`
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_cpp_cast_paren = remove

# Добавить или убрать пробел между `sizeof` и `(`.
# `a=sizeof·(int)`
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_sizeof_paren = remove

# Добавить или убрать пробел между  `sizeof` и `...`
# `template <typename... Args> std::size_t GetSize (Args&&... args) { std::size_t
# Count= sizeof·...(Args);  return Count;}`
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_sizeof_ellipsis = ignore

# Добавить или убрать пробел между  `sizeof...` и `(`.
# `template <typename... Args> std::size_t GetSize (Args&&... args) {
# std::size_t Count= sizeof...·(Args);    return Count;}
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_sizeof_ellipsis_paren = ignore

# Добавить или убрать пробел между `...` и упаковкой параметров.
# template<class R, typename ...·Args>
# void call1r(R(*fp)(Args&&...));
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_ellipsis_parameter_pack = ignore

# Добавить или убрать пробел между упаковкой параметров и `...`.
# template<class R, typename ...Args>
# struct invoke1v : invoke<R(*)(Args·...)>{};
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_parameter_pack_ellipsis = ignore

# Добавить или убрать пробел между  `decltype` и `(`.
# `auto a=decltype·(x){10};`
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_decltype_paren = remove

# (Pawn) Добавить или убрать пробел после ключевого слова tag.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_after_tag = ignore

# Добавить или убрать пробел внутри enum `{` и `}`.
# `enum Status {·Unknown, Success, Error·};`
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_inside_braces_enum = force

# Добавить или убрать пробел внутри struct/union `{` и `}`.
# `union {·int m_size; int m_any;·};`
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_inside_braces_struct = force

# (OC) Добавить или убрать пробел в словаре '{' и `}`
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_inside_braces_oc_dict = ignore

# Добавить или убрать пробел после открывающей скобки в безымянном временном
# прямом списке-инициализации, если оператор является инициализатором списком
# Работает только если `sp_brace_brace` имеет значение `ignore`.
# `int a0[][] = {·{·1}};`
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_after_type_brace_init_lst_open = force

# Добавить или убрать пробел перед закрывающей скобкой в безымянном временном
# прямом списке-инициализации, если оператор является инициализатором списком
# Работает только если `sp_brace_brace` имеет значение `ignore`.
# `int a0[][] = {{1·}·};`
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_before_type_brace_init_lst_close = force

# Добавить или убрать пробел внутри безымянного временного прямого списка-
# инициализации, если оператор является инициализацией списком
# - работает только если `sp_brace_brace` имеет значение `ignore`
# - работает только если `sp_before_type_brace_init_lst_close` имеет значение
# `ignore`.
# `int a0[][] = {·{·1·}·};`
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_inside_type_brace_init_lst = ignore

# Добавить или убрать пробел внутри `{` и `}`.
# `while(1){·i++;·}`
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_inside_braces = force

# Добавить или убрать пробел внутри `{}`.
# `while(1){·}`
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_inside_braces_empty = remove

# Добавить или убрать пробел вокруг оператора `->`.
# `auto max(int a, int b)·->·int;`
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_trailing_return = force

# Добавить или убрать пробел между возвращаемым типом и именем функции.
# Минимум 1 обязателен, за исключением типов возврата указателей.
# `int ·c(int &);int*·c(int &){}`
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_type_func = force

# Добавить или убрать пробел между типом и открывающей скобкой безымянного
# временного прямого списка-инициализации.
# `auto i12 = int·{42};`
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_type_brace_init_lst = remove

# Добавить или убрать пробел между именем функции и `(` в объявлении функции.
# `void f·(int i);`
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_func_proto_paren = remove

# Добавить или убрать пробел между именем функции и '()' при объявлении функции
# без параметров.
# `void f·();`
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_func_proto_paren_empty = remove

# Добавить или убрать пробел между именем функции и `(` при использовании
# спецификатора `typedef`.
# `typedef void timer_cb·(struct timer_node *n);`
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_func_type_paren = remove

# Добавить или убрать пробел между именем псевдонима и `(` типа не указателя
# функции `typedef`.
# `int a·(int b) {};`
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_func_def_paren = remove

# Добавить или убрать пробел между именем функции и `()` в определении функции без
# параметров.
# `int a·() {};`
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_func_def_paren_empty = remove

# Добавляет или удаляет пробел внутри пустых скобок функции `()`.
# Переопределяет `sp_after_angle`, если для `use_sp_after_angle_always` не
# установлено значение `true`.
# `int a (·);`
# `int a (·){}`
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_inside_fparens = remove

# Добавить или убрать пробел внутри скобок функции.
# # void ( int a ) (·int b·);
# int printx(·const char* fmt, ...·);
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_inside_fparen = remove

# Добавить или убрать пробел внутри первых круглых скобок в типе функции
# `void (·*x·)(...)`
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_inside_tparen = remove

# Добавить или убрать пробел между ')' и `(` в типе функции
# `void (*x)·(...)`
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_after_tparen_close = remove

# Добавить или удалять пробел между `]` и `(` при вызове функции.
# `function_list[ idx ]·(param);`
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_square_fparen = ignore

# Добавить или убрать пробел между `)` и `{` в функции.
# `int a (int b)·{};`
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_fparen_brace = force

# Добавить или убрать пробел между `)` и `{` вызова функции при инициализации
# объекта.
# `ProcessStartInfo("smthg")·{Arguments = string.Format("-9 --ss -S aa \"{0}\"",
# file),WorkingDirectory = Directory.GetCurrentDirectory()};`
#
# Переопределяет sp_fparen_brace.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_fparen_brace_initializer = force

# (Java) Добавить или убрать пробел между ')' и '{{' инициализатора двойной
# скобки.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_fparen_dbrace = ignore

# Добавить или убрать пробела между именем функции и `(` при вызове функции.
# `x=sin·(5);`
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_func_call_paren = remove

# Добавить или убрать пробела между именем функции и `()` при вызове функции без
# параметров.
# Если установлено значение `ignore` (по умолчанию), используется
# sp_func_call_paren.
# `x=rand·();`
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_func_call_paren_empty = remove

# Добавить или убрать пробел между именем пользовательской функции и `(` при
# вызове функции.
# Вам нужно установить ключевое слово в качестве пользовательской функции в
# конфигурационном файле, например:
# `set func_call_user tr _ i18n`
# `foo·(ABC)`
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_func_call_user_paren = ignore

# Добавить или убрать пробел внутри скобок пользовательской функции.
# `foo(·ABC·);`
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_func_call_user_inside_fparen = ignore

# Добавить или убрать пробел между вложенными круглыми скобками в пользовательских
# функциях
# `foo(·( ABC )·)`
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_func_call_user_paren_paren = ignore

# Добавить или убрать пробел между конструктором/деструктором и открывающей
# скобкой.
# `myclass·(int i){`
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_func_class_paren = remove

# Добавить или убрать пробел между конструктором без параметров или деструктором и
# `()`.
# `myclass·(){`
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_func_class_paren_empty = remove

# Добавить или убрать пробел после `return`.
# `return·-1;`
#
# Type: ignore / add / remove / force / not_defined
# Default: force 
sp_return = ignore

# Добавить или убрать пробел между `return` и `(`.
# `return·(-1);`
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_return_paren = remove

# Добавить или убрать пробел между `return` и `{`.
# `return·{ -1, -1, -1 };`
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_return_brace = remove

# Добавить или убрать пробел между `__attribute__` и `(`.
# `struct sockaddr *sa __attribute__·((unused))`
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_attribute_paren = remove

# Добавить или убрать пробел между `defined` и `(` в `#if defined (FOO)`.
# `#if defined·(FOO)`
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_defined_paren = force

# Добавить или убрать пробел между `throw` и `(`
# `throw·(something)`
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_throw_paren = ignore

# Добавить или убрать пробел между `throw` и любым другим словом, кроме `(`
# `@throw·[...];`
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_after_throw = ignore

# Добавить или убрать пробел между `catch` и `(` в `catch·(something) { }`.
# Если установлено значение `ignore`, используется `sp_before_sparen`.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_catch_paren = force

# (OC) Добавить или убрать пробел между `@catch` и `(` в `@catch (something) { }`.
# Если установлено значение `ignore`, используется `sp_catch_paren`.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_oc_catch_paren = ignore

# (OC) Добавить или убрать пробел перед списком протоколов Objective-C, как в
# `@protocol Protocol·<Protocol_A>' или '@interface MyClass :
# NSObject·<MyProtocol>'.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_before_oc_proto_list = ignore

# (OC) Добавить или убрать пробел между именем класса и `(` в `@interface
# className·(categoryName)<ProtocolName>:BaseClass`
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_oc_classname_paren = ignore

# (D) Добавить или убрать пробел между `version` и `(` в `version (something) { }`
# Если установлено значение `ignore`, используется `sp_before_sparen`.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_version_paren = ignore

# (D) Добавить или уберать пробел между `scope` и `(` в `scope (something) { }`
# Если установлено значение `ignore`, используется `sp_before_sparen`.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_scope_paren = ignore

# Добавить или убрать пробел между `super` и `(` в `super (something)`.
#
# Type: ignore / add / remove / force / not_defined
# Default: remove 
sp_super_paren = ignore

# Добавить или убрать пробел между `this` и `(`
# `this·(something)`
#
# Type: ignore / add / remove / force / not_defined
# Default: remove 
sp_this_paren = ignore

# Добавить или убрать пробела между именем макроса и его определением.
# `#define FS_NOCOW_FL·0x00800000`
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_macro = ignore

# Добавить или убрать пробела между скобкой макрофункции `)` и ее определением.
# `#define log(x)·qMessage(x.toStdString().c_str());`
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_macro_func = ignore

# Добавить или убрать пробел между 'else' и `{`, если на той же строке.
# `if(i>0){i++;}else·{i=-i;}`
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_else_brace = force

# Добавить или убрать пробел между `}` и `else`, если на той же строке.
# `if(i>0){i++;}·else{i=-i;}`
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_brace_else = force

# Добавить или убрать пробел между `}` и именем набранного текста в той же строке.
# `typedef struct { int val; int sel; }·DiceInfo;`
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_brace_typedef = force

# Добавить или убрать пробел перед `{` оператора `catch`, если они находятся на
# одной строке
# `catch (decl)·{`
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_catch_brace = ignore

# (OC) Добавить или убрать пробел перед '{' оператора '@catch', если `{` и
# '@catch' находятся на одной строке, как в '@catch (decl) <here> {'.<br>
# Если установлено значение ignore, используется sp_catch_brace.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_oc_catch_brace = ignore

# Добавить или убрать пробел между '}' и 'catch', если на той же строке.
# `}·catch (decl){`
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_brace_catch = ignore

# (OC) Добавить или убрать пробел между '}' и '@catch', если они находятся на
# одной строке.<br>
# Если установлено значение ignore, используется sp_brace_catch.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_oc_brace_catch = ignore

# Добавить или убрать пробел между `finally` и `{`, если на той же строке.
# `}finally (decl)·{`
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_finally_brace = ignore

# Добавить или убрать пробел между `}` и `finally`, если на той же строке.
# `}·finally (decl){`
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_brace_finally = ignore

# Добавить или убрать пробел между `try` и `{`, если на той же строке.
# `try·{`
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_try_brace = ignore

# Добавить или убрать пробел между `get/set` и `{`, если на той же строке.
# `public double Seconds
# {
# get·{ return _seconds; }
# set·{ _seconds = value; }
# }`
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_getset_brace = ignore

# Добавить или убрать пробел между переменной и `{` для унифицированной
# инициализации в C++.
# `int a·{5};`
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_word_brace_init_lst = remove

# Добавить или убрать пробела между переменной и `{` для пространства имен.
# `namespace std·{`
#
# Type: ignore / add / remove / force / not_defined
# Default: add 
sp_word_brace_ns = ignore

# Добавить или убрать пробел перед оператором `::`.
# `class Parser·::ParserPrivate { }`
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_before_dc = remove

# Добавить или удалять пробел после оператора `::`
# `class Parser::·ParserPrivate { };`
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_after_dc = remove

# (D) Добавить или убрать вокруг оператора инициализатора имаенованого массива в D
# ':'.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_d_array_colon = ignore

# Добавить или удалять пробел после оператора `!` (не).
# `if(!·a)`
#
# Type: ignore / add / remove / force / not_defined
# Default: remove 
sp_not = remove

# Добавляет или удаляет пробел между двумя унарными операторами '!'.
# Если установлено значение ignore, будет использоваться sp_not.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_not_not = ignore

# Добавить или удалять пробел после оператора `~` (инвертор).
# `int a=~·b;`
#
# Type: ignore / add / remove / force / not_defined
# Default: remove 
sp_inv = remove

# Добавить или убрать пробела после унарного оператора `&` (адрес).
# Это не влияет на пробел после `&`, который является частью типа.
# i=s.toDouble(&·ok);
#
# Type: ignore / add / remove / force / not_defined
# Default: remove 
sp_addr = remove

# Добавить или удалять пробелы вокруг операторов `.` или `->`
# `ui·->·Label1·->·text()·.·toDouble()`
#
# Type: ignore / add / remove / force / not_defined
# Default: remove 
sp_member = remove

# Добавить или убрать пробел после унарного оператора `*` (разыменование).
# Это не влияет на пробел после `*`, который является частью типа.
# `int a=*·b;`
#
# Type: ignore / add / remove / force / not_defined
# Default: remove 
sp_deref = remove

# Добавить или убрать пробел после унарного `+` или `-`
# `x = -·5;y = +·7`
#
# Type: ignore / add / remove / force / not_defined
# Default: remove 
sp_sign = remove

# Добавить или убрать пробел между `++` и `--` словом, к которому он применяется
# `(--·x);y·++;`
#
# Type: ignore / add / remove / force / not_defined
# Default: remove 
sp_incdec = remove

# Добавить или убрать пробел перед обратным слешем в конце строки.
# #define wakeUpCaller(cond)·\
# do { if (log_sev_on(sev)) { log_fmt(sev, ## args); } } while (0)`
#
# Type: ignore / add / remove / force / not_defined
# Default: add 
sp_before_nl_cont = ignore

# (OC) Добавить или убрать пробел после области видимости '+' или '-', как в
# '-(void) foo;' или '+(int) bar;'.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_after_oc_scope = ignore

# (OC) Добавить или убрать пробел после двоеточия в спецификациях сообщений, т.е.
# '-(int) f:(int) x;' против '-(int) f:(int) x;'.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_after_oc_colon = ignore

# (OC) Добавить или убрать пробел перед двоеточием в спецификациях сообщений, т.е.
# '-(int) f: (int) x;' против '-(int) f : (int) x;'.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_before_oc_colon = ignore

# (OC) Добавить или убрать пробел после двоеточия в неизменяемом словарном
# выражении 'NSDictionary *test = @{@"foo" :@"bar"};'.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_after_oc_dict_colon = ignore

# (OC) Добавить или убрать пробел перед двоеточием в неизменяемом словарном
# выражении 'NSDictionary *test = @{@"foo" :@"bar"};'.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_before_oc_dict_colon = ignore

# (OC) Добавить или убрать пробел после двоеточия в спецификациях сообщений, т.е.
# '[object setValue:1];' против '[object setValue: 1];'.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_after_send_oc_colon = ignore

# (OC) Добавить или убрать пробел перед двоеточием в спецификациях сообщений, т.е.
# '[object setValue:1];' против '[object setValue :1];'.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_before_send_oc_colon = ignore

# (OC) Добавить или убрать пробела после (типа) в спецификациях сообщения, т.е.
# '-(int)f: (int) x;' против '-(int)f: (int)x;'.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_after_oc_type = ignore

# (OC) Добавить или убрать пробел после первого (тип) в спецификациях сообщений,
# т.е. '-(int) f:(int)x;' против '-(int)f:(int)x;'.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_after_oc_return_type = ignore

# (OC) Добавить или убрать пробел между '@selector' и `(`, т.е.
# '@selector(msgName)' против '@selector (msgName)'.<br>
# Также относится к конструкциям '@protocol()'.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_after_oc_at_sel = ignore

# (OC) Добавить или убрать пробел между '@selector(x)' и следующим словом, т.е.
# '@selector(foo) a:' против '@selector(foo)a:'.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_after_oc_at_sel_parens = ignore

# (OC) Добавить или убрать пробел внутри скобок '@selector', т.е. '@selector(foo)'
# против '@selector( foo )'.
# Также применяется к конструкциям '@protocol()'.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_inside_oc_at_sel_parens = ignore

# (OC) Добавить или убрать пробел перед кареткой указателя блока, т.е. '^int (int
# arg){...}' против ' ^int (int arg){...}'.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_before_oc_block_caret = ignore

# (OC) Добавить или убрать пробел после каретты указателя блока, т.е. '^int (int
# arg){...}' против '^ int (int arg){...}'.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_after_oc_block_caret = ignore

# (OC) Добавить или убрать пробел между приемником и селектором в сообщении, как в
# '[receiver selector ...]'.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_after_oc_msg_receiver = ignore

# (OC) Добавить или убрать пробел после '@property'.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_after_oc_property = ignore

# (OC) Добавить или убрать пробел между '@synchronized' и открывающей скобкой,
# т.е. '@synchronized(foo)' против '@synchronized (foo)'.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_after_oc_synchronized = ignore

# Добавить или убрать пробел вокруг `:` в `b ? t·:·f`
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_cond_colon = ignore

# Добавить или убрать пробел перед `:` в `b ? t·: f`.
#
# Переопределяет `sp_cond_colon`.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_cond_colon_before = force

# Добавить или убрать пробел после `:` в `b ? t :·f`.
#
# Переопределяет `sp_cond_colon`.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_cond_colon_after = force

# Добавить или убрать место вокруг `?` в `b·?·t : f`.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_cond_question = ignore

# Добавить или убрать пробел перед `?` в `b·? t : f`.
#
# Переопределяет `sp_cond_question`.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_cond_question_before = force

# Добавить или убрать пробел после `?` в `b ?·t : f`.
#
# Переопределяет `sp_cond_question`.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_cond_question_after = force

# В сокращенной тернарной форме `(a?·: b)` добавить или удалить пробел между `?` и
# `:`.
#
# Переопределяет все опции `sp_cond_*`.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_cond_ternary_short = ignore

# Исправить интервал между `case` и меткой.
# Здесь имеют смысл только `ignore` и `force`.
# `case·←←←←2:`
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_case_label = ignore

# (D) Добавить или убрать пробел вокруг оператора D `..`.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_range = ignore

# Добавить или убрать пробел после `:` в основанном на диапазоне `for` в
# Java/C++11
# for (Type var:·expr){}
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_after_for_colon = force

# Добавить или убрать пробел перед `:` в основанном на диапазоне `for` в
# Java/C++11
# for (Type var·:expr){}
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_before_for_colon = force

# (D) Добавить или убрать пробел между 'extern' и `(`, как в 'extern·(C)'.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_extern_paren = ignore

# Добавить или удалять пробел после открытия комментария C++ `//·AAA`
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_cmt_cpp_start = ignore

# Добавить или убрать пробел в комментарии маркера региона C++, как в `// ·
# BEGIN`.
# Маркер региона определяется как комментарий, которому не предшествует другой
# текст (т.е. комментарий является первым не пробелом в строке), и который
# начинается либо с `BEGIN`, либо с `END`.
#
# Переопределяет `sp_cmt_cpp_start`.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_cmt_cpp_region = ignore

# Если переменная имеет значение true, sp_cmt_cpp_start добавляет пробел после
# таких последовательностей, как `///`, `///<`, `//!` и `//!<`.
#
# Type: true/false
# Default: false 
sp_cmt_cpp_doxygen = false

# Если переменная имеет значение true, sp_cmt_cpp_start добавляет пробел после
# таких последовательностей, как `//:`, `//=`, и `//~`.
#
# Type: true/false
# Default: false 
sp_cmt_cpp_qttr = false

# Добавить или убрать пробел между #else или #endif и замыкающим комментарием.
# #if (USE_FIVE) // specmacro
# case 3:
# doFive();
# break;
# #endif·//specmacro
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_endif_cmt = force

# Добавить или удалять пробел после `new`, `delete` и `delete[]`.
# void x(int **d) {
# delete·*d;
# }
# void x(int &d) {
# delete·&d;
# }
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_after_new = force

# Добавить или убрать пробел между `new` и `(` в `new()`.
# Foo* foo = new·(ptr,std::nothrow)Foo[];
# Foo* foo = new·(ptr)Foo();
# Foo* foo = new·(FOO(ptr))Foo();
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_between_new_paren = ignore

# Добавить или убрать пробел между `)` и типом в `new(foo) BAR`.
# Foo* foo = new(ptr,std::nothrow)·Foo[];
# Foo* foo = new(ptr)·Foo();
# Foo* foo = new(FOO(ptr))·Foo();
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_after_newop_paren = ignore

# Добавить или убрать пробел внутри скобки оператора new, как в `new(foo) BAR`.
# Foo* foo = new(·ptr,std::nothrow·)Foo[];
# Foo* foo = new(·ptr·)Foo();
# Foo* foo = new(·FOO(ptr)·)Foo();
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_inside_newop_paren = ignore

# Добавить или убрать пробел после открывающей скобки оператора new
# Foo* foo = new(·ptr,std::nothrow)Foo[];
# Foo* foo = new(·ptr)Foo();
# Foo* foo = new(·FOO(ptr))Foo();
#
# Переопределяет `sp_inside_newop_paren`.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_inside_newop_paren_open = ignore

# Добавить или убрать пробел перед закрывающей скобкой оператора new
# Foo* foo = new(ptr,std::nothrow·)Foo[];
# Foo* foo = new(ptr·)Foo();
# Foo* foo = new(FOO(ptr)·)Foo();
#
# Переопределяет `sp_inside_newop_paren`.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_inside_newop_paren_close = ignore

# Добавить или убрать пробел перед завершающим комментарием.
# return(0);·//cpd.settings[UO_indent_braces].n;
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_before_tr_cmt = ignore

# Количество пробелов перед завершающим комментарием.
#
# Type: unsigned  0  16
# Default: 0 
sp_num_before_tr_cmt = 0

# Добавить или убрать пробел перед встроенным комментарием.
# int a,·/* b , c, */ d; // trailing cmt
#
# Type: ignore / add / remove / force / not_defined
# Default: force 
sp_before_emb_cmt = ignore

# Количество пробелов перед встроенным комментарием.
#
# Type: unsigned  0  16
# Default: 1 
sp_num_before_emb_cmt = 1

# Добавить или убрать пробел после встроенного комментария.
# int a,/* b , c, */·d; // trailing cmt
#
# Type: ignore / add / remove / force / not_defined
# Default: force 
sp_after_emb_cmt = ignore

# Количество пробелов после встроенного комментария.
#
# Type: unsigned  0  16
# Default: 1 
sp_num_after_emb_cmt = 1

# (Java) Добавить или убрать пробел между аннотацией и открывающей круглой
# скобкой.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_annotation_paren = ignore

# Если true, виртуальные фигурные скобки сбрасываются на предыдущий токен и
# пропускаются.
#
# Type: true/false
# Default: false 
sp_skip_vbrace_tokens = false

# Добавить или убрать пробел после `noexcept`.
# Foo() noexcept·() {}
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_after_noexcept = ignore

# Добавить или убрать пробел после `_`.
# new Gtk.Label (_·("Label text"));
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
sp_vala_after_translation = ignore

# Если переменная имеет значение true, то после #define вставляется \t.
# #define USING_TBB 1
# #define⟼USING_TBB 1
#
# Type: true/false
# Default: false 
force_tab_after_define = false


################################################################################
# Параметры отступов
################################################################################

# Количество столбцов для отступа на один уровень. Обычно 2, 3, 4 или 8.
#
# Type: unsigned  0  16
# Default: 8 
indent_columns = 4

# Следует ли игнорировать отступ для первой строки продолжения. Последующие строки
# продолжения будут иметь отступ, соответствующий первой.
#
# Type: true/false
# Default: false 
indent_ignore_first_continue = false

# Отступ продолжения. Если значение ненулевое, оно переопределяет размер отступов
# продолжения для `(`, `[` и `=`.
# Отрицательные значения допустимы; отрицательное значение является абсолютным и
# не увеличивается для каждого уровня `(` или `[`.
# LOG_FMT(LINDLINE, "%s\n", __func__, pc->orig_line, pc->column,
# ····pc->len, pc->str, get_token_name(pc->type), column);
# if ((cout_col > 0) &&
# ····(chunk_is_semicolon(pc) ||
# ····(pc->level < cout_level))) {
# cout_col   = 0;
# cout_level = 0;
# }
#
# Для FreeBSD это значение равно 4.
# Требуется indent_ignore_first_continue=false.
#
# Type: signed  -16  16
# Default: 0 
indent_continue = 0

# Отступ продолжения, только для строки (строк) заголовка класса. Если значение
# ненулевое, это переопределяет отступ продолжения 'class'.
# Требуется indent_ignore_first_continue=false.
#
# Type: unsigned  0  16
# Default: 0 
indent_continue_class_head = 0

# Делать ли отступ для пустых строк (т.е. строк, содержащих только пробелы до
# символа новой строки).
#
# Type: true/false
# Default: false 
indent_single_newlines = false

# Отступ продолжения для `func_*_param`, если они истинны. Если значение
# ненулевое, оно переопределяет отступ.
# LOG_FMT(LINDLINE, format3, __func__, pc->orig_line, pc->column,
# ····pc->len, pc->str, get_token_name(pc->type), column);
#
# Type: unsigned  0  16
# Default: 0 
indent_param = 0

# Как использовать табуляции при создании отступов.
#
# - 0: Только пробелы
# - 1: Отступ табуляцией до уровня скобки, выравнивание пробелами (по умолчанию)
# - 2: Отступ и выравнивание с помощью табуляции, использование пробелов, если нет
# позиции табуляции
#
# Type: unsigned  0  2
# Default: 1 
indent_with_tabs = 0

# Должен ли отступ комментариев, которые не находятся на уровне скобок, отделяться
# табуляцией на tabstop.
# Требуется `indent_with_tabs=2`.
# Если `false`, будут использоваться пробелы.
#
# Type: true/false
# Default: false 
indent_cmt_with_tabs = false

# Делать отступы для строк, разорванных '\', чтобы они выстраивались в одну линию.
# char*s="very long string"
# ↑"very long string"
# ↑"very long string";
#
# Type: true/false
# Default: false 
indent_align_string = false

# Количество пробелов для отступа многострочных XML-строк.
# Требуется `indent_align_string=true`.
# void foo(void) {
# const char *a = "<xml>"
# ··"<data Parent=\"%d\" Name=\"%s\">"
# ····"<Child Id=\"%d\"/>"
# ··"</data>"
# "</xml>";
# }
#
# Type: unsigned  0  16
# Default: 0 
indent_xml_string = 0

# Отступ для скобки `{` от уровня блока.
# if (chunk_is_comment(pc))
# ··{
#
# Type: unsigned  0  16
# Default: 0 
indent_brace = 0

# Раместить скобки на уровне блока кода.
# if (chunk_is_comment(pc))
# ····{
# pc->column = pc->orig_col;
#
# Type: true/false
# Default: false 
indent_braces = false

# Отключить `code_indent_braces` для функций (если `indent_braces=true`).
# void f(double x)
# {
# if (x<0)
# {
# x=fabs(x);
#
# Type: true/false
# Default: false 
indent_braces_no_func = false

# Отключить `code_indent_braces` для классов (если `indent_braces=true`).
# class myclass
# {
# myclass()
# {
# if (ok)
# {
#
# Type: true/false
# Default: false 
indent_braces_no_class = false

# Отключить `code_indent_braces` для структур (если `indent_braces=true`).
# struct mystruct
# {
# mystruct()
# {
# if (ok)
# {
#
# Type: true/false
# Default: false 
indent_braces_no_struct = false

# Отступ должен основываться на размере родительскя скобки, т.е. `if` - 3 пробела,
# `for` - 4 пробела и т.д.
# if (x = 0)              |        if (x = 0)
# {                       |           {
# x++;                |           x++;
# y *= x;             |           y *= x;
# }                       |           }
# for (auto x : y)        |        for (auto x : y)
# {                       |            {
# print(x);           |            print(x);
# }                       |            }
#
# Type: true/false
# Default: false 
indent_brace_parent = false

# Делать отступ на основе открывающей круглой скобки вместо открывающей фигурной
# скобки в `({\n`.
# `false`
# funcCall(match ( [ & ]( const ContentProps &props)  {
# ········return PairingCmpnt()
# }));
# match( [ & ]( const ContentProps &props)  {
# ········return PairingCmpnt()
# });
# `true`
# funcCall(match ( [ & ]( const ContentProps &props)  {
# ········return PairingCmpnt()
# }));
# match( [ & ]( const ContentProps &props)  {
# ········return PairingCmpnt()
# });
#
# Type: true/false
# Default: false 
indent_paren_open_brace = false

# (C#) Добавить отступы от скобки блока `delegate` на следующий уровень.
#
# Type: true/false
# Default: false 
indent_cs_delegate_brace = false

# (C#) Добавить отступы от блока `delegate`, если не используются скобки.
#
# Type: true/false
# Default: false 
indent_cs_delegate_body = false

# Добавить отступы в тело `namespace`.
# namespace Constants
# {
# ····double PI = 3.14;
# }
#
# Type: true/false
# Default: false 
indent_namespace = false

# Отступ только для первого пространства имен, а не для всех вложенных пространств
# имен.
# Требуется `indent_namespace=true`
# namespace std{
# ····namespace math{
# ········namespace constatns{
# ········    const double pi=3.14;
# ········}
# ····}
# }
#
# Type: true/false
# Default: false 
indent_namespace_single_indent = false

# Количество пробелов для отступа блока пространства имен.
# Если установлено в ноль, используется значение `indent_columns`
# namespace Constants{
# ····double PI
#
# Type: unsigned  0  16
# Default: 0 
indent_namespace_level = 0

# Если тело пространства имен длиннее этого числа строк, то отступов не будет.
# Требуется `indent_namespace=true`.
# 0 - без ограничений
#
# Type: unsigned  0  255
# Default: 0 
indent_namespace_limit = 0

# Делать ли отступ только во внутренних пространствах имен (вложенных в другие
# пространства имен).
# Требуется indent_namespace=true.
#
# Type: true/false
# Default: false 
indent_namespace_inner_only = false

# Отступ для тела `extern "C"`.
# extern "C"{
# ····disConnectionH createDisConnection();
# ····int open_DisConnect(disConnectionH record);
# }
#
# Type: true/false
# Default: false 
indent_extern = false

# Отступ в теле класса
# class Widget :
# public QWidget
# {
# ····int a;
# }
#
# Type: true/false
# Default: false 
indent_class = true

# Следует ли игнорировать отступ для ведущего двоеточия базового класса.
#
# Type: true/false
# Default: false 
indent_ignore_before_class_colon = false

# Дополнительный отступ перед ведущим двоеточием базового класса.
# Отрицательные значения уменьшают отступ до первого столбца.
# Требуется indent_ignore_before_class_colon=false и перенос строки перед
# двоеточием (см. pos_class_colon и nl_class_colon).
#
# Type: signed  -16  16
# Default: 0 
indent_before_class_colon = 0

# Добавить отступы после ведущего двоеточия базового класса.
#
# Type: true/false
# Default: false 
indent_class_colon = false

# Отступ основываться на двоеточии класса, а не на том, что находится после
# двоеточия.
# Требуется, чтобы `indent_class_colon=true`.
#
# Type: true/false
# Default: false 
indent_class_on_colon = false

# Следует ли игнорировать отступ для ведущего двоеточия инициализатора класса.
#
# Type: true/false
# Default: false 
indent_ignore_before_constr_colon = false

# Добавить отступы после двоеточия инициализатора ведущего класса.
# void bar_c(int tttt, int uu,
# int abc, int defxx)   : tttt(4444)
# ↑, uu(22), abc(333), defxx(55555)
#
# Type: true/false
# Default: false 
indent_constr_colon = false

# Виртуальный отступ от `:` для ведущих инициализаторов членов.
#
# Type: unsigned  0  16
# Default: 2 
indent_ctor_init_leading = 2

# Виртуальный отступ от `:` для следующих инициализаторов членов.
#
# Type: unsigned  0  16
# Default: 2 
indent_ctor_init_following = 2

# Дополнительный отступ для списка инициализаторов конструктора.
# Отрицательные значения уменьшают отступ до первого столбца.
#
# Type: signed  -16  16
# Default: 0 
indent_ctor_init = 0

# Отступ `if` после `else` должен быть новым блоком под `else`.
# Если `false`, то `else\nif` рассматривается как `else if`.
# if ( true )
# i = 10;
# else
# ····if ( true )
# ····    i = 10;
#
# Type: true/false
# Default: false 
indent_else_if = false

# Сумма отступов объявлений переменных после открывающей скобки.
#
# -  <0: Относительный
# - >=0: Абсолютный
#
# Type: signed  -16  16
# Default: 0 
indent_var_def_blk = 0

# Добавить отступы от разбитых определений переменных вместо выравнивания.
# false                  | true
# static uint jhash(K x) | static uint jhash(K x)
# {                      | {
# ubyte *k;          |     ubyte *k;
# uint a,            |     uint a,
# b,            |         b,
# c;            |         c;
#
# Type: true/false
# Default: false 
indent_var_def_cont = false

# Как сделать отступ для выражений с продолженным сдвигом (`<<` и `>>`).
# При его использовании установите align_left_shift=false.
# 0: Выравнивать операторы сдвига вместо отступов (по умолчанию)
# 1: Отступ на один уровень
# -1: Сохранять исходный отступ
#
# Type: signed  -1  1
# Default: 0 
indent_shift = 0

# Определение функций начинаться в колонке 1.
# struct foobar {
# char *foobarz() { //!
# return "foobar";
# }
# char *foo_bar() { //!
# return "foo_bar";
# }
# int foo;
# };
#
# Type: true/false
# Default: false 
indent_func_def_force_col1 = false

# Добавить отступы для разбитых параметров вызова функции на один уровень отступа,
# а не выравнивать параметры под открывающей круглой скобкой.
# false       ↓            |  true
# Type tmp = f(getObj().x,  |   Type tmp = f(getObj().x,
# getObj().y,  |   ····getObj().y,
# getObj().z,  |   ····getObj().z,
# getObj().w); |   ····getObj().w);
# ↑
#
# Type: true/false
# Default: false 
indent_func_call_param = false

# Добавить отступы для разбитых параметров в определении функции, а не выравнивать
# параметры под открывающей круглой скобкой.
# false    ↓                        | true
# void bar(int someval,             | void bar(int someval,
# void *puser,             | ····void *puser,
# const char *filename,    | ····const char *filename,
# struct willy *the_list,  | ····struct willy *the_list,
# int list_len)            | ····int list_len)
# {        ↑                        | {
# int idx;                      |     int idx;
#
# Type: true/false
# Default: false 
indent_func_def_param = false

# Для определений функции при `indent_func_def_param=false` позволяет выравнивать
# параметры или делать отступы при необходимости. Если скобка расположена на
# позиции больше данного числа, то делается отступ, иначе выравнивание.
# ↓
# void f(int x,  ↓
# int y,  ↓
# int z)  ↓
# ↑       ↓
# void very_long_function(int x,
# ····int y,
# ····int z)
#
# Type: unsigned  0  160
# Default: 0 
indent_func_def_param_paren_pos_threshold = 20

# Добавить отступы для разбитых параметров в объявлении функции, а не выравнивать
# параметры под открывающей круглой скобкой.
# false    ↓                        | true
# void bar(int someval,             | void bar(int someval,
# void *puser,             | ····void *puser,
# const char *filename,    | ····const char *filename,
# struct willy *the_list,  | ····struct willy *the_list,
# int list_len);           | ····int list_len);
#
# Type: true/false
# Default: false 
indent_func_proto_param = false

# Добавить отступы для разбитых параметров в определении функции класса, а не
# выравнивать параметры под открывающей круглой скобкой.
# false   ↓                       |     true
# T :: T (const std::string& ns,  |     T :: T (const std::string& ns,
# const std::string& ns1, |     ····const std::string& ns1,
# const std::string& ns2) |     ····const std::string& ns2)
# {                               |     {
# |
# }                               |     }
# struct MyClass : public Foo {   |     struct MyClass : public Foo {
# ↓                   |
# MyClass(int a,              |         MyClass(int a,
# int b,              |         ····int b,
# int c)              |         ····int c)
# : m_a(a) {              |             : m_a(a) {
# }                           |         }
# };                              |     };
#
# Type: true/false
# Default: false 
indent_func_class_param = false

# Добавить отступы для разбитых параметров в конструкторе, а не выравнивать
# параметры под открывающей круглой скобкой.
#
# Type: true/false
# Default: false 
indent_func_ctor_var_param = false

# Добавить отступы для разбитых параметров шаблона, а не выравнивать параметры под
# открывающей круглой скобкой.
# ↓
# template          |  template
# <typename T,      |  <typename T,
# typename U>      |  ····typename U>
# void h(T s, U t)  |  void h(T s, U t)
#
# Type: true/false
# Default: false 
indent_template_param = false

# Удвоить отступ для опций `indent_func_xxx_param`.
# Использет оба значения опций `indent_columns` и `indent_param`.
#
# Type: true/false
# Default: false 
indent_func_param_double = false

# Колонка отступов для отдельного квалификатора 'const' в прототипе функции.
# void GetFoo(void)
# ····const
# {
# return (m_Foo);
# }
#
# Type: unsigned  0  69
# Default: 0 
indent_func_const = 0

# Колонка для отдельного квалификатора 'throw' в прототипе функции.
# int GetFoo(void)
# ····throw (std::bad_alloc)
# {
# return (m_Foo);
# }
#
# Type: unsigned  0  41
# Default: 0 
indent_func_throw = 0

# Как делать отступ внутри макроса со скобкой на той же строке
# Это позволяет уменьшить отступ в макросах, которые содержат,например, `do { ...
# } while (0)`.
#
# - true: добавлять отступ для скобки в той же строке, что и макрос
# - false: не добавлять отступ для скобки в той же строке, что и макрос
#
# Type: true/false
# Default: true 
indent_macro_brace = true

# Количество пробелов для отступа от продолжения `->` или `.`.
# Обычно устанавливается в 0, 1 или `indent_columns`.
# sass.asdfvas->asdfasd[asdfasdf].
# ····asdfasdf = 5;
# ::asdasda::adasd::
# ····asdfasdf = 5;
#
# Type: unsigned  0  16
# Default: 0 
indent_member = 4

# Должны ли строки, разорванные на `.` или `->`, отступать на один отступ.
# Опция `indent_member` не будет действовать, если установлено значение `true`.
# sass.asdfvas->asdfasd[asdfasdf].
# ····asdfasdf = 5;
# adasd->
# ····asdfasdf = 5;
#
# Type: true/false
# Default: false 
indent_member_single = false

# Пробелы для отступов однострочных ('//') комментариев.
#
# Type: unsigned  0  16
# Default: 0 
indent_single_line_comments_before = 0

# Пробелы для отступа однострочных ('//') комментариев на строках после кода.
#
# Type: unsigned  0  16
# Default: 0 
indent_single_line_comments_after = 0

# При открытии круглой скобки для управляющего оператора (if, for, while и т.д.)
# увеличить уровень отступа на это значение. Отрицательные значения уменьшают
# уровень отступа.
#
# Type: signed  -16  16
# Default: 0 
indent_sparen_extra = 0

# Нужно ли делать отступ для комментариев в одну строку ('//') относительно кода
# вместо того, чтобы пытаться сохранить тот же абсолютный столбец.
#
# Type: true/false
# Default: false 
indent_relative_single_line_comments = false

# Размер отступа `case` от `switch`. Обычно 0 или `indent_columns`.
# Возможно, будет разумно выбрать такое же значение для параметра
# `indent_case_brace`.
# switch(i) {
# ··case 1: [[fallthrough]];
# [[likely]] case 2: return 1;
# }
#
# Type: unsigned  0  16
# Default: 0 
indent_switch_case = 0

# Пробелы для отступа тела `switch` перед любым `case`.
# Обычно то же самое, что и `indent_columns` или `indent_switch_case`.
#
# Type: unsigned  0  16
# Default: 0 
indent_switch_body = 0

# Следует ли игнорировать отступ для '{' после 'case'.
#
# Type: true/false
# Default: false 
indent_ignore_case_brace = false

# Пробел для отступа `{` от `case`. По умолчанию скобка будет отображаться под
# буквой `c` в `case`.
# Обычно устанавливается равным 0 или `indent_columns`.
# Отрицательные значения допустимы.
# Возможно, имеет смысл выбрать такое же значение для параметра
# `indent_switch_case`.
#
# Type: signed  -16  16
# Default: 0 
indent_case_brace = 4

# Отступ `break` от `switch`
# switch (message_p)             | switch (message_p)
# {                              | {
# case A:                        | case A:
# {                              | {
# const tab* ent2 = f( _p ); |     const tab* ent2 = f( _p );
# tab* ent3 = f( _p );       |     tab* ent3 = f( _p );
# }                              | }
# break;                         | break;
# | ↓
# case B:                        | case B:
# const tab* ent2 = f( _p ); |     const tab* ent2 = f( _p );
# tab* ent3 = f( _p );       |     tab* ent3 = f( _p );
# ····break;                     | break;
#
# Type: true/false
# Default: false 
indent_switch_break_with_case = false

# Добавить отступы для препроцессорных утверждений внутри утверждений switch.
#
# Type: true/false
# Default: true 
indent_switch_pp = true

# Пробел для сдвига строки `case`, не затрагивая другие строки.
# Обычно 0.
# switch(i) {
# ··case 1: [[fallthrough]];
# [[likely]] case 2: return 1;
# }
#
# Type: unsigned  0  16
# Default: 0 
indent_case_shift = 0

# Выравнивать комментарии перед 'case' по 'case'.
#
# Type: true/false
# Default: true 
indent_case_comment = true

# Делать отступ для комментариев, не найденных в первой колонке.
#
# Type: true/false
# Default: true 
indent_comment = true

# Отступы для  комментариев, найденных в первой колонке.
# ··// the main func
# void main(int, char**){
#
# Type: true/false
# Default: false 
indent_col1_comment = true

# Делать отступ в первой колонке в многострочном литерале.
#
# Type: true/false
# Default: false 
indent_col1_multi_string_literal = false

# Лимит столбцов для выравнивания комментариев на соседних строках
#
# Type: unsigned  0  16
# Default: 3 
indent_comment_align_thresh = 3

# Игнорировать отступ для меток goto.
#
# Type: true/false
# Default: false 
indent_ignore_label = false

# Как размещать метки goto.
# Требуется `indent_ignore_label=false`.
#
# - =0: Абсолютный столбец, где 1 - самый левый столбец
# - <=0: Вычитание из отступа скобки
#
# Type: signed  -16  16
# Default: 1 
indent_label = 1

# Отступы для спецификаторов доступа, за которыми следует двоеточие.
# class A{
# ··piblic:
#
# - >0: Абсолютный столбец, где 1 - самый левый столбец
# - <=0: Вычитание из отступа скобки
#
# Type: signed  -16  16
# Default: 1 
indent_access_spec = 1

# Добавить отступ кода после спецификатора доступа на один уровень.
# Если true, эта опция заставляет `indent_access_spec=0`.
# class{
# int b;
# public:
# ··int a;
#
# Type: true/false
# Default: false 
indent_access_spec_body = false

# Если за открывающей круглой скобкой следует новая строка, добавлять отступ на
# следующей строке так, чтобы она начиналась после открывающей круглой скобки (не
# рекомендуется).
# void method51(        | void method51(↓
# ····int i,            |               int i,
# ····Some l,           |               Some l,
# ····float f,          |               float f,
# ····double d,         |               double d,
# ····const string & s) |               const string & s)
#
# Type: true/false
# Default: false 
indent_paren_nl = false

# Отступ от ближайшей скобки после новой строки.
# 0  ↓              1  ↓           2↓
# x=f(x,            x=f(x,          x=f(x,
# ↓                ↓              ↓
# y(5,              y(5,            y(5,
# 6                 6               6
# ),               ),             ),
# 12                12              12
# )                )            )
#
# - 0: Отступ до уровня тела (по умолчанию)
# - 1: Выравнивание по открытой скобке
# - 2: Отступ на уровне скобки
# - -1: Сохранить исходный отступ
#
# Type: signed  -1  2
# Default: 0 
indent_paren_close = 0

# Делать отступ от открывающей скобки определения функции, если скобка находится
# на отдельной строке.
#
# Type: true/false
# Default: false 
indent_paren_after_func_def = false

# Нужно ли делать отступ от открывающей скобки объявления функции, если скобка
# находится на отдельной строке.
# void method51(                              |   void method51(↓
# ····int int_param,                          |                 int int_param,
# ····SomeLongNamespace long_parameter_name,  |
# SomeLongNamespace     long_parameter_name,
# ····float float_param,                      |                 float
# float_param,
# ····double double_param,                    |                 double
# double_param,
# ····const string & string_param);           |                 const string &
# string_param);
#
# Type: true/false
# Default: false 
indent_paren_after_func_decl = false

# Делать отступ от открывающей скобки вызова функции, если скобка находится на
# отдельной строке.
#
# Type: true/false
# Default: false 
indent_paren_after_func_call = false

# Как сделать отступ для запятой внутри скобок.
# -  0: Отступ на один уровень (по умолчанию)
# -  1: Выравнивание по открытой скобке
# - -1: Сохранить исходный отступ
#
# Type: signed  -1  1
# Default: 0 
indent_comma_brace = 0

# Как сделать отступ для запятой внутри круглых скобок.
# -  0: Отступ на один уровень (по умолчанию)
# -  1: Выравнивание по открытой круглой скобке
# - -1: Сохранить исходный отступ
#
# Type: signed  -1  1
# Default: 0 
indent_comma_paren = 0

# Как сделать отступ для булевого оператора внутри круглых скобок.
# -  0: Отступ на один уровень (по умолчанию)
# -  1: Выравнивание по открытой круглой скобке
# - -1: Сохранить исходный отступ
#
# Type: signed  -1  1
# Default: 0 
indent_bool_paren = 0

# Следует ли игнорировать отступ логического оператора, когда он находится за
# пределами круглых скобок.
#
# Type: true/false
# Default: false 
indent_ignore_bool = false

# Следует ли игнорировать отступы арифметического оператора.
#
# Type: true/false
# Default: false 
indent_ignore_arith = false

# Нужно ли делать отступ для точки с запятой внутри скобки for.
# Если true, то выравнивается под открывающей круглой скобкой.
#
# Type: true/false
# Default: false 
indent_semicolon_for_paren = false

# Следует ли игнорировать отступ от точки с запятой вне оператора `for`.
#
# Type: true/false
# Default: false 
indent_ignore_semicolon = false

# Выравнивать ли первое выражение по последующим, если indent_bool_paren=1.
#
# Type: true/false
# Default: false 
indent_first_bool_expr = true

# Выравнивать первое выражение по последующим, если
# `indent_semicolon_for_paren=true`.
#
# Type: true/false
# Default: false 
indent_first_for_expr = false

# Если за открывающей фигурной скобкой следует новая строка, добавлять отступ на
# следующей строке так, чтобы она начиналась после открывающей фигурной скобки (не
# рекомендуется).
#
# Type: true/false
# Default: false 
indent_square_nl = false

# (ESQL/C) Сохранить относительный отступ 'EXEC SQL'.
#
# Type: true/false
# Default: false 
indent_preserve_sql = false

# Следует ли игнорировать отступы оператора присваивания.
#
# Type: true/false
# Default: false 
indent_ignore_assign = false

# Выравнивать разорванные утверждения по '='.
# Если false или если за '=' следует новая строка, отступ следующей строки
# составляет одну табуляцию.
#
# Type: true/false
# Default: true 
indent_align_assign = true

# Если true, то отступ фрагментов после последовательности '=' будет
# устанавливаться по адресу LHS столбца отступа лексемы перед '='.
#
# Type: true/false
# Default: false 
indent_off_after_assign = false

# Выравнивать разорванные утверждения по `(`.
# Если false или за `(` следует новая строка, отступ следующей строки составляет
# одну табуляцию.
#
# Type: true/false
# Default: true 
indent_align_paren = true

# (OC) Отступы от кода Objective-C внутри селекторов сообщений.
#
# Type: true/false
# Default: false 
indent_oc_inside_msg_sel = false

# (OC) Отступы в блоках Objective-C на уровне скобок вместо обычных правил.
#
# Type: true/false
# Default: false 
indent_oc_block = false

# (OC) Отступ для блоков Objective-C в сообщении относительно имени параметра.
#
# - =0: Использовать правила `indent_oc_block`
# - >0: Использовать заданное количество пробелов для отступа
#
# Type: unsigned  0  16
# Default: 0 
indent_oc_block_msg = 0

# (OC) Минимальный отступ для последующих параметров
#
# Type: unsigned  0  5000
# Default: 0 
indent_oc_msg_colon = 0

# (OC) Приоритетно ли выравнивание по начальному двоеточию (и удаление пробелов из
# строк, если необходимо).
#
# Type: true/false
# Default: true 
indent_oc_msg_prioritize_first_colon = true

# (OC) Отступ для блоков так, как это делает Xcode по умолчанию (от ключевого
# слова, если параметр находится на своей строке; в противном случае - от
# предыдущего уровня отступа).
# Требуется, чтобы `indent_oc_block_msg=true`.
#
# Type: true/false
# Default: false 
indent_oc_block_msg_xcode_style = false

# (OC) Отступ блоков от места расположения скобки относительно ключевого слова
# сообщения.
# Требуется, чтобы `indent_oc_block_msg=true`.
#
# Type: true/false
# Default: false 
indent_oc_block_msg_from_keyword = false

# (OC) Отступ блоков от места скобки относительно двоеточия сообщения.
# Требуется, чтобы `indent_oc_block_msg=true`
#
# Type: true/false
# Default: false 
indent_oc_block_msg_from_colon = false

# (OC) Отступ блока от места, где находится обводка блока.
# Требуется, чтобы `indent_oc_block_msg=true`.
#
# Type: true/false
# Default: false 
indent_oc_block_msg_from_caret = false

# (OC) Отступ блока от места, где находится скобка.
# Требуется, чтобы `indent_oc_block_msg=true`.
#
# Type: true/false
# Default: false 
indent_oc_block_msg_from_brace = false

# При отступе после открывающей виртуальной скобки и новой строки добавить
# дополнительные пробелы, чтобы достичь этого минимального отступа.
#
# Type: unsigned  0  16
# Default: 0 
indent_min_vbrace_open = 0

# Добавить дополнительные пробелы после обычного отступа для достижения следующего
# tabstop при отступе после открывающей виртуальной скобки и новой строки.
#
# Type: true/false
# Default: false 
indent_vbrace_open_on_tabstop = false

# Как сделать отступ после скобки, за которой следует другой маркер (не новая
# строка).
# - true: отступ от всех содержащихся строк, чтобы соответствовать маркеру
# - false: отступ от всех содержащихся строк, чтобы соответствовать скобке.
#
# Type: true/false
# Default: true 
indent_token_after_brace = true

# Добавить отступы в теле лямбды C++11.
#
# Type: true/false
# Default: false 
indent_cpp_lambda_body = false

# Как делать отступ для составных литералов, которые возвращаются.
# - true: добавить отступ от возврата и открывающей скобки составного литерала
# (т.е. 2 уровня отступа)
# - false: только 1 уровень отступа, не добавлять отступ для открывающей скобки,
# добавить отступ только для возврата.
#
# Type: true/false
# Default: true 
indent_compound_literal_return = false

# (C#) Добавить отступы блока `using`, если не используются скобки.
#
# Type: true/false
# Default: true 
indent_using_block = true

# Отступы для разбитого тернарного оператора.
#
# - 0: Выключено (по умолчанию)
# - 1: Когда `if_false` является продолжением, отступ под `if_false`.
# - 2: Если `:` является продолжением, отступ под `?`.
#
# Type: unsigned  0  2
# Default: 0 
indent_ternary_operator = 0

# Отступы для утверждений внутри тернарного оператора.
#
# Type: true/false
# Default: false 
indent_inside_ternary_operator = false

# Если переменная имеет значение true, то строке после выражения `return` будет
# установлен отступ как у return.
#
# Type: true/false
# Default: false 
indent_off_after_return = false

# Если переменная имеет значение true, то строке после выражения `return new`
# будет установлен отступ как у return.
#
# Type: true/false
# Default: false 
indent_off_after_return_new = false

# Если `true`, то лексемы после `return` будут иметь обычный одинарный отступ.
# По умолчанию (`false`) отступ делается относительно лексемы `return`.
#
# Type: true/false
# Default: false 
indent_single_after_return = false

# Игнорировать отступ и выравнивание для блоков `asm` (т.е. считать, что они имеют
# свой собственный отступ).
#
# Type: true/false
# Default: false 
indent_ignore_asm_block = false

# Не делать отступ для закрывающей скобки определения функции, если скобка
# находится на отдельной строке.
#
# Type: true/false
# Default: false 
donot_indent_func_def_close_paren = false


################################################################################
# Параметры добавления и удаления новых строк
################################################################################

# Нужно ли сворачивать пустые блоки между '{' и `}`.
# Если `true`, то отменяет действие `nl_inside_empty_func`
#
# Type: true/false
# Default: false 
nl_collapse_empty_body = false

# Не разбивать однострочные фигурные скобки в присваивании, как в `foo_t f = { 1,
# 2 };`.
#
# Type: true/false
# Default: false 
nl_assign_leave_one_liners = true

# Не разбивать однострочные скобки внутри тела `class xxx{}`.
#
# Type: true/false
# Default: false 
nl_class_leave_one_liners = true

# Не разбивать однострочные перечисления, как в `enum foo { BAR = 15 };`
#
# Type: true/false
# Default: false 
nl_enum_leave_one_liners = true

# Не разбивать однострочные функции get/set.
#
# Type: true/false
# Default: false 
nl_getset_leave_one_liners = true

# (C#) Не разбивать однострочный функции свойств get и set.
#
# Type: true/false
# Default: false 
nl_cs_property_leave_one_liners = false

# Не разбивать определения однострочных функций, как в `int foo() { return 0; }`.
# Может модифицировать `nl_func_type_name`
#
# Type: true/false
# Default: false 
nl_func_leave_one_liners = false

# Не разбивать однострочные лямбды C++11, как в `[]() { return 0; }`.
#
# Type: true/false
# Default: false 
nl_cpp_lambda_leave_one_liners = false

# Не разбивать однострочные операторы `if`/`else`, как в `if(...) b++;`
#
# Type: true/false
# Default: false 
nl_if_leave_one_liners = false

# Не разбивать однострочные операторы `while`
#
# Type: true/false
# Default: false 
nl_while_leave_one_liners = false

# Не разбивать однострочные операторы `do`, как в `do { b++; } while(...);`.
#
# Type: true/false
# Default: false 
nl_do_leave_one_liners = false

# Не разбивать однострочные операторы `for`, как в `for(...) b++;`.
#
# Type: true/false
# Default: false 
nl_for_leave_one_liners = false

# (OC) Не разбивать однострочные сообщения Objective-C.
#
# Type: true/false
# Default: false 
nl_oc_msg_leave_one_liner = false

# (OC) Добавить или убрать новую строку между объявлением метода и `{`.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
nl_oc_mdef_brace = ignore

# (OC) Добавить или убрать новую строку между сигнатурой блока Objective-C и `{`.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
nl_oc_block_brace = ignore

# (OC) Добавить или убрать пустую строку перед оператором `@interface`.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
nl_oc_before_interface = ignore

# (OC) Добавить или убрать пустую строку перед оператором `@implementation`.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
nl_oc_before_implementation = ignore

# (OC) Добавить или убрать пустую строку перед оператором `@end`.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
nl_oc_before_end = ignore

# (OC) Добавить или убрать новую строку между `@interface` и `{`.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
nl_oc_interface_brace = ignore

# (OC) Добавить или убрать новую строку между `@implementation` и `{`.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
nl_oc_implementation_brace = ignore

# Добавить или убрать новые строки в начале файла.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
nl_start_of_file = remove

# Минимальное количество новых строк в начале файла (используется только если
# `nl_start_of_file` имеет значение `add` или `force`).
#
# Type: unsigned  0  16
# Default: 0 
nl_start_of_file_min = 0

# Добавить или убрать новые строки в конце файла.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
nl_end_of_file = force

# Минимальное количество новых строк в конце файла (используется только если
# `nl_end_of_file` имеет значение `add` или `force`).
#
# Type: unsigned  0  16
# Default: 0 
nl_end_of_file_min = 1

# Добавить или убрать новую строку между `=` и `{`.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
nl_assign_brace = add

# (D) Добавить или убрать новую строку между `=` и `[`.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
nl_assign_square = ignore

# Добавить или убрать новую строку между `[]` и `{`.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
nl_tsquare_brace = ignore

# (D) Добавить или убрать новую строку после `= [`. Это также влияет на новую
# строку перед `]`.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
nl_after_square_assign = ignore

# Добавить или удалить новую строку между `)` и `{` в вызове функции, как в
# примере `list_for_each(item, &list)¶ { }`.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
nl_fcall_brace = add

# Добавить или убрать новую строку между `enum` и `{`.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
nl_enum_brace = force

# Добавить или убрать новую строку между `enum` и `class`.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
nl_enum_class = remove

# Добавить или убрать новую строку между `enum class` и идентификатором.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
nl_enum_class_identifier = remove

# Добавить или убрать новую строку между `enum class` и двоеточием перед типом.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
nl_enum_identifier_colon = remove

# Добавить или убрать новую строку между `enum class identifier :` и типом.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
nl_enum_colon_type = remove

# Добавить или убрать новую строку между `struct` и `{`.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
nl_struct_brace = add

# Добавить или убрать новую строку между `union` и `{`.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
nl_union_brace = add

# Добавить или убрать новую строку между `if` и `{`.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
nl_if_brace = force

# Добавить или убрать новую строку между `}` и `else`.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
nl_brace_else = remove

# Добавить или удалить новую строку между `else if` и `{`.
# Если установлено значение `ignore`, вместо него используется `nl_if_brace`.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
nl_elseif_brace = add

# Добавить или убрать новую строку между `else` и `{`.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
nl_else_brace = remove

# Добавить или убрать новую строку между `else` и `if`.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
nl_else_if = remove

# Добавить или убрать новую строку перед открывающейся фигурной скобкой `{`
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
nl_before_opening_brace_func_class_def = force

# Добавить или убрать новую строку перед закрывающей круглой скобкой `if`/`else
# if`.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
nl_before_if_closing_paren = remove

# Добавить или убрать новую строку между `}` и `finally`.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
nl_brace_finally = ignore

# Добавить или убрать новую строку между `finally` и `}`.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
nl_finally_brace = add

# Добавить или убрать новую строку между `try` и `{`.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
nl_try_brace = add

# Добавить или убрать новую строку между get/set и `{`.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
nl_getset_brace = ignore

# Добавить или убрать новую строку между `for` и `{`.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
nl_for_brace = add

# Добавить или удалить новую строку перед `{` оператора `catch`, как в примере
# 'catch (decl) ¶ {'.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
nl_catch_brace = add

# (OC) Добавить или удалить новую строку перед `{` оператора `@catch`, как в
# `@catch (decl) ¶ {`.
# Если установлено значение игнорировать, используется `nl_catch_brace`.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
nl_oc_catch_brace = ignore

# Добавить или убрать новую строку между `}` и `catch`.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
nl_brace_catch = force

# (OC) Добавить или убрать новую строку между '}' и '@catch'.
# Если установлено `ignore`, используется `nl_brace_catch`.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
nl_oc_brace_catch = ignore

# Добавить или убрать новую строку между `}` и `]`.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
nl_brace_square = ignore

# Добавить или убрать новую строку между `}` и `)` при вызове функции.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
nl_brace_fparen = remove

# Добавить или убрать новую строку между `while` и `{`.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
nl_while_brace = add

# (D) Добавить или убрать новую строку между `scope (x)` и `{`.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
nl_scope_brace = ignore

# (D) Добавить или убрать новую строку между `unittest` и `{`.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
nl_unittest_brace = ignore

# (D) Добавить или убрать новую строку между `version (x)` и `{`.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
nl_version_brace = ignore

# (C#) Добавить или убрать конец строки между `using` и `{`.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
nl_using_brace = ignore

# Добавить или удалить новую строку между двумя закрывающими или открывающими
# фигурными скобками. Из-за общей работы с новой строкой и скобками, REMOVE может
# не сработать.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
nl_brace_brace = force

# Добавить или убрать новую строку между `do` и `{`.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
nl_do_brace = add

# Добавить или убрать пробел между `}` и `while` в конструкции `do`.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
nl_brace_while = remove

# Добавить или убрать новую строку между `switch` и `{`.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
nl_switch_brace = add

# (D) Добавить или убрать новую строку между `synchronized` и `{`.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
nl_synchronized_brace = ignore

# Добавить новую строку между `)` и `{`, если `)` находится на другой строке, чем
# if/for/etc.
# if (x==y
# && x==z)¶{x++;}
#
# Переопределяет `nl_for_brace`, `nl_if_brace`, `nl_switch_brace`,
# `nl_while_switch` и `nl_catch_brace`.
#
# Type: true/false
# Default: false 
nl_multi_line_cond = false

# Добавить новую строку после `(`, если условие `if`/`for`/`while`/`switch`
# охватывает несколько строк
# if (¶x==y
# && x==z){}
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
nl_multi_line_sparen_open = ignore

# Добавить новую строку перед `)`, если условие `if`/`for`/`while`/`switch`
# охватывает несколько строк.
# Отменяет `nl_before_if_closing_paren`, если указаны оба.
# if (x==y
# && x==z¶)
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
nl_multi_line_sparen_close = ignore

# Принудительное добавление новой строки для многострочного определения макроса
# после объявления
# #define CTOR(i, _)¶ : \
# T(X()), \
# y() \
# { }
#
# Type: true/false
# Default: false 
nl_multi_line_define = false

# Добавить новую строку перед `case` и пустую строку перед `case`, который следует
# за `;` или `}`.
# switch (a){
# case 1:¶ case 2:
# x=7;
# ¶case 5:
# x=3;
# ¶case 7:
# x=8;
# }
#
# Type: true/false
# Default: false 
nl_before_case = true

# Добавить или убрать пустую строку после оператора `case`.
#
# Type: true/false
# Default: false 
nl_after_case = true

# Добавить или убрать новую строку между `:` и `{` в `case`.
#
# Переопределяет `nl_after_case`.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
nl_case_colon_brace = force

# Добавить или убрать новую строку между `)` и `throw`
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
nl_before_throw = ignore

# Добавить или убрать новую строку между `namespace` и `}`.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
nl_namespace_brace = force

# Добавить или убрать новую строку после `template<...>` в шаблоне класса.
# template <class T>¶struct type1;
# template <int>¶struct type2 {
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
nl_template_class = ignore

# Добавить или убрать новую строку после `template<...>` в объявлении класса.
# template <class T>¶struct type;
#
# Переопределяет `nl_template_class`.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
nl_template_class_decl = remove

# Добавить или убрать новую строку после `template<...>` в объявлении
# специализации класса.
# template <int>¶struct type;
#
# Переопределяет `nl_template_class_decl`.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
nl_template_class_decl_special = ignore

# Добавить или убрать новую строку после `template<...>` в определении класса.
# template <class T>¶struct type {
#
# Переопределяет `nl_template_class`.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
nl_template_class_def = force

# Добавить или убрать новую строку после `template<...>` в определении
# специализации класса.
# template <int>¶struct type{
#
# Переопределяет `nl_template_class_def`.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
nl_template_class_def_special = ignore

# Добавить или убрать новую строку после `template<...>` в шаблоне функции.
# template <class T>¶T fun1(T x);
# template <int>¶T fun2(T x){
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
nl_template_func = ignore

# Добавить или убрать новую строку после `template<...>` в объявлении шаблоной
# функции.
# template <class T>¶T fun(T x);
#
# Переопределяет `nl_template_func`.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
nl_template_func_decl = remove

# Добавить или убрать новую строку после `template<...>` в специализированном
# определении шаблоной функции.
# template <double>¶double fun(doubel x);
#
# Переопределяет `nl_template_func_decl`.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
nl_template_func_decl_special = ignore

# Добавить или убрать новую строку после `template<...>` в реализации шаблоной
# функции.
# template <class T>¶T fun(T x){
#
# Переопределяет `nl_template_func`.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
nl_template_func_def = force

# Добавить или убрать новую строку после `template<...>` в специализированной
# реализации шаблоной функции.
# template <double>¶double fun(doubel x){
#
# Переопределяет `nl_template_func_def`.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
nl_template_func_def_special = ignore

# Добавить или убрать новую строку после `template<...>` в шаблонной переменной.
# template <class T> ¶pi=T(M_PI);
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
nl_template_var = remove

# Добавить или убрать новую строку между `template<...>` и using в алиасе типа.
# template<class T>¶using Vec = vector<T, Alloc<T> >;
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
nl_template_using = remove

# Добавить или убрать новую строку между `class` и `{`.
# class X : public Mixins ... ¶{
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
nl_class_brace = force

# Добавить или удалить новую строку до или после (в зависимости от
# `pos_class_comma`, который не может быть IGNORE) каждой запятой `,` в списке
# базовых классов.
# class MyClass : public Foo,¶private Bar {
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
nl_class_init_args = ignore

# Добавить или удалить новую строку после каждой запятой `,` в списоке
# инициализаторов членов конструктора.
# Связано с `nl_constr_colon`, `pos_constr_colon` и `pos_constr_comma`.
# MyClass(int a, int b, int c)
# : m_a(a),¶ m_b(b),¶ m_c(c) {
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
nl_constr_init_args = force

# Добавить или удалить новую строку перед первым элеиментом, после запятой и после
# послежнего элемента `enum`
# enum class form:int{¶one,¶ two¶};
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
nl_enum_own_lines = ignore

# Добавить или удалить новую строку между возвращаемым типом и именем функции в
# определении функции.
# может быть модифицирован командой `nl_func_leave_one_liners`
# double¶f(dounle x){return x;}
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
nl_func_type_name = remove

# Добавить или удалить новую строку между возвращаемым типом и именем функции в
# функции внутри определения класса.
# Если `ignore`, используется `nl_func_type_name` или `nl_func_proto_type_name`.
# class mc{
# double¶f(dounle x){return x;}
# double¶g(dounle x);
# }
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
nl_func_type_name_class = remove

# Добавить или удалить новую строку между спецификацией класса и `::` в `void
# A¶::f() { }`.
# Появляется только в реализации отдельного члена (не появляется при встроенной
# реализации).
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
nl_func_class_scope = remove

# Добавить или удалить новую строку между областью действия функции и ее именем
# void A::¶f() { }
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
nl_func_scope_name = remove

# Добавить или убрать новую строку между типом возврата и именем функции в
# объявлении.
# void ¶Function();
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
nl_func_proto_type_name = remove

# Добавить или убрать новую строку между именем функции и открывающей скобкой
# списка параметров в объявлении.
# void Function¶(double x);
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
nl_func_paren = remove

# Переопределяет `nl_func_paren` для функций без параметров.
# void Function¶();
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
nl_func_paren_empty = remove

# Добавить или убрать новую строку между именем функции и открывающей скобкой
# списка параметров в определении.
# void Function¶(double x){return x;}
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
nl_func_def_paren = remove

# Переопределяет `nl_func_def_paren` для функций без параметров.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
nl_func_def_paren_empty = remove

# Добавить или убрать новую строку между именем функции и открывающей скобкой
# списка параметров в вызове.
# Function¶(5);
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
nl_func_call_paren = remove

# Переопределяет `nl_func_call_paren` для функций без параметров.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
nl_func_call_paren_empty = remove

# Добавить или убрать новую строку после `(` в объявлении функции.
# void Function(¶double x);
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
nl_func_decl_start = remove

# Добавить или убрать новую строку после `(` в определении функции.
# void Function(¶double x){}
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
nl_func_def_start = remove

# Переопределяет `nl_func_decl_start` при наличии только одного параметра.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
nl_func_decl_start_single = remove

# Переопределяет `nl_func_def_start` при наличии только одного параметра.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
nl_func_def_start_single = remove

# Добавить новую строку после `(` в объявлении функции, если `(` и `)` находятся в
# разных строках.
# Если `false`, то вместо этого используется `nl_func_decl_start`.
#
# Type: true/false
# Default: false 
nl_func_decl_start_multi_line = false

# Добавить новую строку после `(` в определении функции, если `(` и `)` находятся
# в разных строках.
# Если `false`, то вместо этого используется `nl_func_def_start`.
#
# Type: true/false
# Default: false 
nl_func_def_start_multi_line = false

# Добавить или убрать новую строку после каждой `,` в объявлении функции.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
nl_func_decl_args = remove

# Добавить или убрать новую строку после каждой `,` в определении функции.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
nl_func_def_args = ignore

# Добавить или убрать новую строку после каждой `,` в вызове функции.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
nl_func_call_args = ignore

# Добавить новую строку после каждой запятой `,` в объявлении функции, если `(` и
# `)` находятся в разных строках.
# Если `false`, то вместо этого используется `nl_func_decl_args`.
#
# Type: true/false
# Default: false 
nl_func_decl_args_multi_line = false

# Добавить новую строку после каждой запятой `,` в определении функции, если `(` и
# `)` находятся в разных строках.
# Если `false`, то вместо этого используется `nl_func_def_args`.
#
# Type: true/false
# Default: false 
nl_func_def_args_multi_line = false

# Добавить или убрать новую строку перед символом `)` в объявлении функции.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
nl_func_decl_end = remove

# Добавить или убрать новую строку перед символом `)` в определении функции.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
nl_func_def_end = remove

# Переопределяет `nl_func_decl_end` при наличии только одного параметра.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
nl_func_decl_end_single = remove

# Переопределяет `nl_func_def_end` при наличии только одного параметра.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
nl_func_def_end_single = remove

# Добавить новую строку перед скобкой `)` в объявлении функции, если `(` и `)`
# находятся в разных строках.
# Если `false`, то вместо этого используется `nl_func_decl_end`.
#
# Type: true/false
# Default: false 
nl_func_decl_end_multi_line = false

# Добавить новую строку перед скобкой `)` в определении функции, если `(` и `)`
# находятся в разных строках.
# Если `false`, то вместо этого используется `nl_func_def_end`.
#
# Type: true/false
# Default: false 
nl_func_def_end_multi_line = false

# Добавить или убрать новую строку между `()` в объявлении функции.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
nl_func_decl_empty = remove

# Добавить или убрать новую строку между `()` в определении функции.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
nl_func_def_empty = remove

# Добавить или убрать новую строку между `()` при вызове функции.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
nl_func_call_empty = remove

# Добавить новую строку после `(` в вызове функции, имеет проритет над
# `nl_func_call_start_multi_line`.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
nl_func_call_start = ignore

# Добавить новую строку перед `)` при вызове функции.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
nl_func_call_end = ignore

# Добавить новую строку после `(` в вызове функции, если скобки расположены на
# разных строках
#
# Type: true/false
# Default: false 
nl_func_call_start_multi_line = false

# Добавить новую строку после каждой запятой в списке параметров вызова функции,
# если скобки расположены на разных строках.
#
# Type: true/false
# Default: false 
nl_func_call_args_multi_line = false

# Добавить новую строку перед `)` в вызове функции, если скобки расположены на
# разных строках
#
# Type: true/false
# Default: false 
nl_func_call_end_multi_line = false

# Соблюдать опцию `nl_func_call_XXX` в случае аргументов замыкания.
#
# Type: true/false
# Default: false 
nl_func_call_args_multi_line_ignore_closures = false

# Добавить новую строку после `<` в списке параметров шаблона.
# template<¶class A, class B> struct test;
#
# Type: true/false
# Default: false 
nl_template_start = false

# Добавить новую строку после каждой запятой в списке параметров шаблона.
# template<class A,¶ class B,¶ class C> struct test;
#
# Type: true/false
# Default: false 
nl_template_args = false

# Добавить новую строку перед `>` в списке параметров шаблона.
# template<class A, class B¶> struct test;
#
# Type: true/false
# Default: false 
nl_template_end = false

# (OC) Помещать каждый параметр сообщения Objective-C в отдельную строку.
# См. `nl_oc_msg_leave_one_liner`
#
# Type: true/false
# Default: false 
nl_oc_msg_args = false

# Добавить или убрать новую строку между сигнатурой функции и `{`.
# double f(double x)¶{return x;}
# double f(double x)const ¶{return x;}
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
nl_fdef_brace = force

# Добавить или убрать новую строку между сигнатурой функции и `{`, если сигнатура
# заканчивается скобкой.
# Переопределяет `nl_fdef_brace`.
# double f(double x){return x;}
# double f(double x)const ¶{return x;}
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
nl_fdef_brace_cond = force

# Добавить или убрать новую строку между лямбда-сигнатурой C++11 и `{`.
# [=](double x)¶{return x;}
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
nl_cpp_ldef_brace = ignore

# Добавить или убрать новую строку между `return` и выражением return.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
nl_return_expr = remove

# Добавить новую строку после точки с запятой, кроме как в утверждении `for`.
#
# Type: true/false
# Default: false 
nl_after_semicolon = true

# (Java) Добавить или убрать новую строку между `)` и `{{` в инициализаторе.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
nl_paren_dbrace_open = ignore

# Добавлять ли новую строку после типа в неименованном временном прямом списке
# инициализации.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
nl_type_brace_init_lst = force

# Добавлять ли новую строку после открывающей скобки в неименованном временном
# прямом списке инициализации.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
nl_type_brace_init_lst_open = force

# Добавлять ли новую строку перед закрывающей скобкой в неименованном временном
# прямом списке инициализации.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
nl_type_brace_init_lst_close = force

# Добавить новую строку перед `{`.
#
# Type: true/false
# Default: false 
nl_before_brace_open = false

# Добавить новую строку после `{`.
#
# Type: true/false
# Default: false 
nl_after_brace_open = true

# Добавить новую строку между открытой скобкой и завершающим однострочным
# комментарием.
# Требуется `nl_after_brace_open=true`
#
# Type: true/false
# Default: false 
nl_after_brace_open_cmt = false

# Добавить новую строку после виртуальной скобки, открытой с непустым телом.
# Это происходит в телах операторов `if`/`while`/`do`/`for` без скобок.
# if(x<0)¶ x=-x;
#
# Type: true/false
# Default: false 
nl_after_vbrace_open = true

# Добавить новую строку после виртуальной скобки, открытой с пустым телом.
# Это происходит в телах операторов `if`/`while`/`do`/`for` без скобок.
# while(process())¶;
#
# Type: true/false
# Default: false 
nl_after_vbrace_open_empty = false

# Добавить новую строку после `}`. Не применяется, если за ним следует необходимая
# `;`.
#
# Type: true/false
# Default: false 
nl_after_brace_close = true

# Добавить новую строку после закрытия виртуальной скобки, как в `if (foo)
# a++;¶return;`.
#
# Type: true/false
# Default: false 
nl_after_vbrace_close = false

# Добавить или удалить новую строку между закрывающей скобкой и идентификатором,
# как в `struct { int a; } ¶ b;`.
# Действует на перечисления, объединения и структуры.
# Если установлено значение `ignore`, используется `nl_after_brace_close`.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
nl_brace_struct_var = ignore

# Вставлять новые строки в тело макроса #define
#
# Type: true/false
# Default: false 
nl_define_macro = false

# Добавлять новые строки между последовательными закрывающими скобками. Количество
# закрывающих круглых скобок в строке будет зависеть от соответствующих открытых
# скобок.
#
# Type: true/false
# Default: false 
nl_squeeze_paren_close = false

# Удалять пробелы после '#ifxx' и '#elxx', или перед '#elxx' и '#endif'. Не влияет
# на #ifdef верхнего уровня.
#
# Type: true/false
# Default: false 
nl_squeeze_ifdef = true

# Заставляет опцию `nl_squeeze_ifdef` влиять и на верхний уровень #ifdefs.
#
# Type: true/false
# Default: false 
nl_squeeze_ifdef_top_level = false

# Добавить или убрать пустую строку перед `if`.
# ¶if(x!=y)x=y;
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
nl_before_if = force

# Добавить или убрать пустую строку после оператора `if`.
# if(x!=y)x=y;¶
# `Add`/`Force` работает только в том случае, если следующая лексема не является
# закрывающей скобкой.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
nl_after_if = force

# Добавить или убрать пустую строку перед `for`.
# ¶for(int i=0; i!=10;i++){...}
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore
nl_before_for = force

# Добавить или убрать пустую строку после оператора `for`.
# for(int i=0; i!=10;i++){...}¶
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore
nl_after_for = force

# Добавить или убрать пустую строку перед `while`.
# ¶while(i!=10){i++;}
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore
nl_before_while = force

# Добавить или убрать пустую строку после оператора `while`.
# while(i!=10){i++;};¶
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore
nl_after_while = remove

# Добавить или убрать пустую строку перед `switch`.
# ¶switch(i){...}
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore
nl_before_switch = force

# Добавить или убрать пустую строку после оператора `switch`.
# switch(i){...}¶
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore
nl_after_switch = force

# Добавить или убрать пустую строку перед `synchronized`
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore
nl_before_synchronized = ignore

# Добавить или убрать пустую строку после оператора `synchronized`.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore
nl_after_synchronized = ignore

# Добавить или убрать пустую строку перед `do`.
# ¶do{i++;}while(i!=10);
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore
nl_before_do = force

# Добавить или убрать пустую строку после оператора `do/while`.
# do{i++;}while(i!=10);¶
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore
nl_after_do = force

# Игнорировать `nl_before_{if,for,switch,do,synchronized}`, если управляющий
# оператор находится сразу после оператора `case`.
# Если для параметра `nl_before_{if,for,switch,do}` установлено значение `remove`,
# этот параметр ничего не делает.
#
# Type: true/false
# Default: false
nl_before_ignore_after_case = true

# Добавить пустую строку перед значением 'return', если не после открывающей
# скобки.
# x=5;¶return 3;
#
# Type: true/false
# Default: false
nl_before_return = true

# Ставить ли пустую строку после оператора 'return', если за ним не следует
# закрывающая скобка.
# return 3;¶
#
# Type: true/false
# Default: false
nl_after_return = true

# Ставить ли пустую строку перед операторами `.` или `->`.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore
nl_before_member = ignore

# (Java) Добавить пустую строку после операторов `.` или `->`.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore
nl_after_member = remove

# Две новые строки перед комментарием в `struct`/`union`/`enum`.
#
# Type: true/false
# Default: false
nl_ds_struct_enum_cmt = false

# Нужно ли принудительно ставить новую строку перед `}` в `struct`/`union`/`enum`.
# (Более низкий приоритет, чем `eat_blanks_before_close_brace`).
#
# Type: true/false
# Default: false
nl_ds_struct_enum_close_brace = false

# Добавить или удалить новую строку до или после (в зависимости от
# `pos_class_colon`, который не может быть IGNORE) двоеточия в списке базовых
# классов.
# class MyClass :¶ public Foo, private Bar {
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore
nl_class_colon = remove

# Добавить или удалить новую строку вокруг двоеточия конструктора класса. Точное
# положение зависит от `nl_constr_init_args`, `pos_constr_colon` и
# `pos_constr_comma`.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore
nl_constr_colon = force

# Следует ли свернуть двухстрочное пространство имен, например, 'namespace foo¶{
# decl; }' в одну строку.
# Если `true`, то предотвращает превращение такого кода в четыре строки другими
# правилами переноса строк.
# Если `true`, то также сохраняет однострочные пространства имен.
#
# Type: true/false
# Default: false
nl_namespace_two_to_one_liner = false

# Удалять ли новую строку в простых , безскобочных операторах `if`, превращая их в
# однострочные
# if(b)¶ i++
#
# Type: true/false
# Default: false
nl_create_if_one_liner = false

# Удалять новую строку в простых операторах `for` без скобок, превращая их
# в однострочные
# for (...)¶ stmt;
#
# Type: true/false
# Default: false
nl_create_for_one_liner = false

# Удалять новую строку в простых операторах `while` без скобок, превращая их
# в однострочные
# while (...)¶ stmt;
#
# Type: true/false
# Default: false
nl_create_while_one_liner = false

# Следует ли свернуть определение функции, тело которой (без учета скобок)
# составляет всего одну строку, чтобы все определение (прототип, скобки, тело)
# было одной строкой.
#
# Type: true/false
# Default: false
nl_create_func_def_one_liner = false

# Следует ли разбивать однострочные определения простых списков на три строки
# путем
# добавлением новых строк, как в `int a[12] = { ¶ 0 ¶ };`.
#
# Type: true/false
# Default: false
nl_create_list_one_liner = false

# Разделять простые однострочные операторы `if` без скобок на две строки путём
# добавлением новой строки,
# if(b) ¶i++;
#
# Type: true/false
# Default: false
nl_split_if_one_liner = false

# Разделять простые однострочные операторы `for` без скобок на две строки путём
# добавлением новой строки,
# for(...) ¶i++;
#
# Type: true/false
# Default: false
nl_split_for_one_liner = false

# Разбивать однострочные простые операторы while без скобок на две строки путем
# добавлением новой строки
# `while (expr) ¶ stmt;`
#
# Type: true/false
# Default: false
nl_split_while_one_liner = false

# Не добавлять новую строку перед cpp-комментарием в списке параметров вызова
# функции.
#
# Type: true/false
# Default: false
donot_add_nl_before_cpp_comment = true


################################################################################
# Параметры пустых строк
################################################################################

# Максимальное количество последовательных новых строк (3 = 2 пустые строки).
#
# Type: unsigned  0  16
# Default: 0
nl_max = 3

# Максимальное количество последовательных новых строк в функции.
#
# Type: unsigned  0  16
# Default: 0
nl_max_blank_in_func = 0

# Количество пустых строк внутри пустого тела функции.
# Эта опция отменяет действие опций `eat_blanks_after_open_brace` и
# `eat_blanks_before_close_brace`, но игнорируется, когда
# `nl_collapse_empty_body=true`
#
# Type: unsigned  0  16
# Default: 0
nl_inside_empty_func = 0

# Количество пустых строк перед прототипом функции.
#
# Type: unsigned  0  16
# Default: 0
nl_before_func_body_proto = 0

# Количество новых строк перед многострочным определением функции. Там, где это
# применимо, этот параметр переопределяется с помощью
# `eat_blanks_after_open_brace=true`
#
# Type: unsigned  0  16
# Default: 0
nl_before_func_body_def = 3

# Количество пустых строк перед прототипом конструктора/деструктора.
#
# Type: unsigned  0  16
# Default: 0
nl_before_func_class_proto = 0

# Количество пустых строк перед определением конструктора/деструктора класса.
#
# Type: unsigned  0  16
# Default: 0
nl_before_func_class_def = 0

# Количество пустых строк после прототипа функции.
#
# Type: unsigned  0  16
# Default: 0
nl_after_func_proto = 1

# Количество пустых строк после прототипа функции, если за ним не следует другой
# прототип функции.
#
# Type: unsigned  0  16
# Default: 0
nl_after_func_proto_group = 2

# Количество пустых строк после прототипа конструктора/деструктора класса.
#
# Type: unsigned  0  16
# Default: 0
nl_after_func_class_proto = 0

# Количество пустых строк после прототипа конструктора/деструктора класса, если за
# ним не следует другой прототип конструктора/деструктора.
#
# Type: unsigned  0  16
# Default: 0
nl_after_func_class_proto_group = 0

# Рассматривать однострочные определения методов в теле класса как прототипы (для
# целей добавления новых строк )
#
# Требуется `nl_class_leave_one_liners=true`
# Отменяет `nl_before_func_body_def` и `nl_before_func_class_def` для однострочных
# символов.
#
# Type: true/false
# Default: false
nl_class_leave_one_liner_groups = true

# Количество пустых строк после финальной фигурной скобки `}` многострочного тела
# функции.
#
# Type: unsigned  0  16
# Default: 0
nl_after_func_body = 0

# Количество пустых строк после `}` многострочного тела функции в объявлении
# класса. Также влияет на конструкторы/деструкторы классов.
#
# Переопределяет `nl_after_func_body`.
#
# Type: unsigned  0  16
# Default: 0
nl_after_func_body_class = 0

# Количество пустых строк после `}` однострочного тела функции в объявлении
# класса. Также влияет на конструкторы/деструкторы классов.
#
# Переопределяет `nl_after_func_body` и `nl_after_func_body_class`.
#
# Type: unsigned  0  16
# Default: 0
nl_after_func_body_one_liner = 0

# Количество пустых строк после блока определений переменных в верхней части тела
# функции.
#
# 0: не изменять (по умолчанию).
#
# Type: unsigned  0  16
# Default: 0
nl_func_var_def_blk = 1

# Количество пустых строк перед блоком типизаций. Если `nl_after_access_spec`
# ненулевое, этот параметр имеет приоритет.
#
# 0: не изменять (по умолчанию).
#
# Type: unsigned  0  16
# Default: 0
nl_typedef_blk_start = 0

# Количество пустых строк после блока `typedefs`.
#
# 0: не изменять (по умолчанию).
#
# Type: unsigned  0  16
# Default: 0
nl_typedef_blk_end = 0

# Максимальное количество последовательных пустых строк в блоке `typedef`.
#
# 0: не изменять (по умолчанию).
#
# Type: unsigned  0  16
# Default: 0
nl_typedef_blk_in = 0

# Количество пустых строк перед блоком определений переменных не в верхней части
# тела функции. Если `nl_after_access_spec` имеет ненулевое значение, то этот
# параметр имеет приоритет.
#
# 0: не изменять (по умолчанию).
#
# Type: unsigned  0  16
# Default: 0
nl_var_def_blk_start = 2

# Количество пустых строк поле блока определений переменных не в верхней части
# тела функции.
#
# 0: не изменять (по умолчанию).
#
# Type: unsigned  0  16
# Default: 0
nl_var_def_blk_end = 2

# Максимальное количество последовательных пустых строк в блоке определения
# переменных.
#
# 0: не изменять (по умолчанию).
#
# Type: unsigned  0  16
# Default: 0
nl_var_def_blk_in = 0

# Минимальное количество новых строк перед многострочным комментарием.
# Не применяется, после открывающей скобки или другого многострочного комментария.
#
# Type: unsigned  0  16
# Default: 0
nl_before_block_comment = 0

# Минимальное количество новых строк перед однострочным C-комментарием.
# Не применяется, после открывающей скобки или другого однострочного комментария.
#
# Type: unsigned  0  16
# Default: 0
nl_before_c_comment = 0

# Минимальное количество новых строк перед CPP-комментарием.
# Не применяется, после открывающей скобки или другого комментария.
#
# Type: unsigned  0  16
# Default: 0
nl_before_cpp_comment = 0

# Добавить нувую строку после многострочного комментария.
#
# Type: true/false
# Default: false
nl_after_multiline_comment = false

# Добавить новую строку после двоеточия метки.
#
# Type: true/false
# Default: false
nl_after_label_colon = false

# Количество пустых строк перед определением структуры.
#
# Type: unsigned  0  16
# Default: 0
nl_before_struct = 0

# Количество пустых строк после финальных `}` или `;` определения
# `struct`/`enum`/`union`.
#
# Type: unsigned  0  16
# Default: 0
nl_after_struct = 0

# Количество пустых строк перед определением класса.
#
# Type: unsigned  0  16
# Default: 0
nl_before_class = 0

# Количество пустых строк после финальных `}` или `;` определения класса.
#
# Type: unsigned  0  16
# Default: 0
nl_after_class = 0

# Количество пустых строк перед определением области имен.
#
# Type: unsigned  0  16
# Default: 0
nl_before_namespace = 2

# Количество пустых строк после `{` в пространстве имен. Это также добавляет новые
# строки перед соответствующим `}`.
#
# 0: Применить `eat_blanks_after_open_brace` или `eat_blanks_before_close_brace`,
# если применимо, иначе никаких изменений.
#
# Переопределяет `eat_blanks_after_open_brace` и `eat_blanks_before_close_brace`.
#
# Type: unsigned  0  16
# Default: 0
nl_inside_namespace = 2

# Количество пустых строк после финальной фигурной скобки `}` пространства имён.
#
# Type: unsigned  0  16
# Default: 0
nl_after_namespace = 2

# Количество пустых строк перед меткой спецификатора доступа. Это также включает
# специфические для Qt `signals:` и `slots:`. Не изменяет количество новых строк
# если после открытой скобки.
#
# 0: не изменять (по умолчанию).
#
# Type: unsigned  0  16
# Default: 0
nl_before_access_spec = 2

# Количество пустых строк после спецификатора доступа. Это также включает
# специфические для Qt `signals:` и `slots:`. Не изменяет количество новых строк
# если после открытой скобки. скобки.
#
# 0: не изменять (по умолчанию).
#
# Переопределяет `nl_typedef_blk_start` и `nl_var_def_blk_start`.
#
# Type: unsigned  0  16
# Default: 0
nl_after_access_spec = 2

# Количество новых строк между определением функции и ее комментарием
# // комментарий
# ¶ void foo() {...}
#
# 0: не изменять (по умолчанию).
#
# Type: unsigned  0  16
# Default: 0
nl_comment_func_def = 1

# Количество новых строк после блока try-catch-finally, за которым не следует
# закрывающей скобкой.
#
# 0: не изменять (по умолчанию).
#
# Type: unsigned  0  16
# Default: 0
nl_after_try_catch_finally = 0

# (C#) Количество новых строк до и после объявления свойства, индексатора или
# события.
#
# 0: не изменять (по умолчанию).
#
# Type: unsigned  0  16
# Default: 0
nl_around_cs_property = 0

# (C#) Количество новых строк между обработчиками get/set/add/remove.
#
# 0: не изменять (по умолчанию).
#
# Type: unsigned  0  16
# Default: 0
nl_between_get_set = 0

# (C#) Добавить или убрать конец строки между свойством (property) и `{`.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore
nl_property_brace = ignore

# Удалить пустые строки после `{`.
#
# Type: true/false
# Default: false
eat_blanks_after_open_brace = true

# Удалить пустые строки перед `}`.
#
# Type: true/false
# Default: false
eat_blanks_before_close_brace = true

# Насколько агресивно удалять лишние строки не в препроцессоре.
#
# - 0: Без изменений (по умолчанию)
# - 1: Удалить большинство новых строк, не обрабатываемых другими конфигурациями
# - 2: Удалить все пустые строки и полностью переформатировать с помощью
# конфигурации
#
# Type: unsigned  0  2
# Default: 0
nl_remove_extra_newlines = 0

# (Java) Добавить или убрать новую строку после оператора аннотации.
# Влияет только на аннотации, которые находятся после новой строки.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore
nl_after_annotation = ignore

# (Java) Добавить или убрать новую строку между двумя аннотациями.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore
nl_between_annotation = ignore

# Количество новых строк перед #ifdef файла.
# См. include guards
#
# 0: не изменять (по умолчанию).
#
# Type: unsigned  0  16
# Default: 0
nl_before_whole_file_ifdef = 0

# Количество новых строк после #ifdef файла.
# См. include guards
#
# 0: не изменять (по умолчанию).
#
# Type: unsigned  0  16
# Default: 0
nl_after_whole_file_ifdef = 0

# Количество новых строк перед #endif файла.
# См. include guards
#
# 0: не изменять (по умолчанию).
#
# Type: unsigned  0  16
# Default: 0
nl_before_whole_file_endif = 0

# Количество новых строк после #endif файла.
# См. include guards
#
# 0: не изменять (по умолчанию).
#
# Type: unsigned  0  16
# Default: 0
nl_after_whole_file_endif = 0


################################################################################
# Параметры позиционирования
################################################################################

# Положение арифметических операторов при свертке выражаний.
#
# Type: ignore/break/force/lead/trail/join/lead_break/lead_force/trail_break/trail_force
# Default: ignore
pos_arith = ignore

# Позиция присваивания в свернутых выражениях. Не влияет на '=' за которым следует
# '{'.
#
# Type: ignore/break/force/lead/trail/join/lead_break/lead_force/trail_break/trail_force
# Default: ignore
pos_assign = ignore

# Положение логических операторов при свертке выражаний.
#
# Type: ignore/break/force/lead/trail/join/lead_break/lead_force/trail_break/trail_force
# Default: ignore
pos_bool = lead

# Положение операторов сравнения при свертке выражаний.
#
# Type: ignore/break/force/lead/trail/join/lead_break/lead_force/trail_break/trail_force
# Default: ignore
pos_compare = ignore

# Положение условных операторов, как в символах `?` и ':' из выражения `expr ?
# stmt : stmt`, в свернутых выражениях.
#
# Type: ignore/break/force/lead/trail/join/lead_break/lead_force/trail_break/trail_force
# Default: ignore
pos_conditional = ignore

# Положение запятой при свертке выражаний.
#
# Type: ignore/break/force/lead/trail/join/lead_break/lead_force/trail_break/trail_force
# Default: ignore
pos_comma = ignore

# Положение запятой в элементах перечисления.
#
# Type: ignore/break/force/lead/trail/join/lead_break/lead_force/trail_break/trail_force
# Default: ignore
pos_enum_comma = trail_force

# Положение запятой в списке базовых классов, если в нем более одной строк. Влияет
# на `nl_class_init_args`.
#
# Type: ignore/break/force/lead/trail/join/lead_break/lead_force/trail_break/trail_force
# Default: ignore
pos_class_comma = ignore

# Позиция запятой в списке инициализации конструктора.
# Связано с `nl_constr_colon`, `nl_constr_init_args` и `pos_constr_colon`.
#
# Type: ignore/break/force/lead/trail/join/lead_break/lead_force/trail_break/trail_force
# Default: ignore
pos_constr_comma = lead_force

# Положение двоеточия следующего/ведущего класса, между классом и списком базовых
# классов. Влияет на `nl_class_colon`.
#
# Type: ignore/break/force/lead/trail/join/lead_break/lead_force/trail_break/trail_force
# Default: ignore
pos_class_colon = ignore

# Положение двоеточий между конструктором и инициализацией членов.
# Связано с `nl_constr_colon`, `nl_constr_init_args` и `pos_constr_comma`.
#
# Type: ignore/break/force/lead/trail/join/lead_break/lead_force/trail_break/trail_force
# Default: ignore
pos_constr_colon = lead_break

# Положение операторов сдвига в свернутых выражениях.
#
# Type: ignore/break/force/lead/trail/join/lead_break/lead_force/trail_break/trail_force
# Default: ignore
pos_shift = ignore


################################################################################
# Параметры разбивки строк
################################################################################

# Пытаться ограничить ширину кода N столбцами.
#
# Type: unsigned  0  10000
# Default: 0
code_width = 120

# Разделять длинные выражения `for` полностью (на три строки)
#
# Type: true/false
# Default: false
ls_for_split_full = false

# Полностью разделять длинные прототипы/вызовы функций по запятым.
# Опция `ls_code_width` имеет приоритет над опцией `ls_func_split_full`.
#
# Type: true/false
# Default: false
ls_func_split_full = false

# Разбивать строки как можно ближе к ширине кода и игнорировать некоторые
# группировки.
# Опция `ls_code_width` имеет приоритет над опцией `ls_func_split_full`.
#
# Type: true/false
# Default: false
ls_code_width = false


################################################################################
# Опции выравнивания кода (не левые пробелы)
################################################################################

# Сохранять табуляции, не относящиеся к отступам.
#
# Type: true/false
# Default: false
align_keep_tabs = false

# Использовать табуляцию для выравнивания.
#
# Type: true/false
# Default: false
align_with_tabs = false

# Переходить при выравнивании на следующую позицию табуляции.
#
# Type: true/false
# Default: false
align_on_tabstop = false

# Выравнивать цифры по правому краю.
#
# Type: true/false
# Default: false
align_number_right = true

# Сохранять пробелы ненужные для выравнивания.
#
# Type: true/false
# Default: false
align_keep_extra_space = false

# Выравнивать определения переменных в прототипах и функциях.
#
# Type: true/false
# Default: false
align_func_params = true

# Размах для выравнивания определений параметров в функции по имени параметра.
#
# 0: не выравнивать (по умолчанию).
#
# Type: unsigned  0  16
# Default: 0
align_func_params_span = 0

# Порог для выравнивания определений параметров функции.
# Для абсолютных порогов используйте отрицательное число.
#
# 0: без ограничений (по умолчанию).
#
# Type: signed  -1000  5000
# Default: 0
align_func_params_thresh = 0

# Зазор в выравнивании параметров функций в определении.
#
# Type: unsigned  0  16
# Default: 0
align_func_params_gap = 0

# Размах для выравнивания значений конструктора.
#
# 0: не выравнивать (по умолчанию).
#
# Type: unsigned  0  16
# Default: 0
align_constr_value_span = 0

# Порог для выравнивания параметров конструктора.
# Для абсолютных порогов используйте отрицательное число.
#
# 0: без ограничений (по умолчанию).
#
# Type: signed  -1000  5000
# Default: 0
align_constr_value_thresh = 0

# Зазор для выравнивания параметров в конструкторе.
#
# Type: unsigned  0  16
# Default: 0
align_constr_value_gap = 0

# Выравнивать параметры в однострочных функциях, имеющих одинаковое имя. Имена
# функций уже должны быть выровнены друг относительно друга.
#
# Type: true/false
# Default: false
align_same_func_call_params = false

# Размах для выравнивания параметров вызова функции для однострочных функций.
#
# 0: не выравнивать (по умолчанию).
#
# Type: unsigned  0  5000
# Default: 0
align_same_func_call_params_span = 0

# Порог для выравнивания параметров вызова функций для однострочных функции.
# Для абсолютных порогов используйте отрицательное число.
#
# 0: без ограничений (по умолчанию).
#
# Type: signed  -1000  5000
# Default: 0
align_same_func_call_params_thresh = 0

# Размах для выравнивания определений переменных.
#
# 0: не выравнивать (по умолчанию).
#
# Type: unsigned  0  5000
# Default: 0
align_var_def_span = 2

# Как учитывать  `*` при выравнивании определений переменных.
#
# - 0: Часть типа `long *·······foo;`
# - 1: Часть переменной `long·······* foo;`
# - 2: Висячая `long * foo;`
# Висячая: `*` не будет учитываться при выравнивании.
#
# Type: unsigned  0  2
# Default: 0
align_var_def_star_style = 1

# Как учитывать '&' при выравнивании определений переменных.
#
# - 0: Часть типа `long &·······foo;`
# - 1: Часть переменной `long·······& foo;`
# - 2: Висячая `long & foo;`
# Висячая: `&` не будет учитываться при выравнивании.
#
# Type: unsigned  0  2
# Default: 0
align_var_def_amp_style = 1

# Порог для выравнивания определений переменных.
# Для абсолютных порогов используйте отрицательное число.
#
# 0: без ограничений (по умолчанию).
#
# Type: signed  -1000  5000
# Default: 0
align_var_def_thresh = 0

# Зазор для выравнивания определений переменных.
#
# Type: unsigned  0  16
# Default: 0
align_var_def_gap = 0

# Выравнивать двоеточие битовых полей.
#
# Type: true/false
# Default: false
align_var_def_colon = true

# Зазор при выравнивании двоеточия битовых полей.
#
# Type: unsigned  0  16
# Default: 0
align_var_def_colon_gap = 0

# Выравнивать любой атрибут после имени переменной.
#
# Type: true/false
# Default: false
align_var_def_attribute = false

# Выравнивать определения встроенных в struct/enum/union переменных.
#
# Type: true/false
# Default: false
align_var_def_inline = true

# Размах для выравнивания по '=' в присваивании.
#
# 0: не выравнивать (по умолчанию).
#
# Type: unsigned  0  5000
# Default: 0
align_assign_span = 1

# Размах для выравнивания по '{' в скобочном списке инициализации.
#
# 0: не выравнивать (по умолчанию).
#
# Type: unsigned  0  5000
# Default: 0
align_braced_init_list_span = 0

# Размах для выравнивания по '=' в модификаторе прототипа функции.
#
# 0: не выравнивать (по умолчанию).
#
# Type: unsigned  0  5000
# Default: 0
align_assign_func_proto_span = 4

# Порог для выравнивания по '=' в присваивании.
# Для абсолютных порогов используйте отрицательное число.
#
# 0: без ограничений (по умолчанию).
#
# Type: signed  -1000  5000
# Default: 0
align_assign_thresh = 0

# Нужно ли выравнивать по самому левому присваиванию, если в одной строке
# встречается несколько определений.
# Зависит от настроек 'align_assign_span' и 'align_assign_thresh'.
#
# Type: true/false
# Default: false
align_assign_on_multi_var_defs = false

# Порог для выравнивания по '{' в скобочном списке инициализации.
# Для абсолютного порога используйте отрицательное число.
#
# 0: без ограничений (по умолчанию).
#
# Type: signed  -1000  5000
# Default: 0
align_braced_init_list_thresh = 0

# Как применить `align_assign_span` к "присвоениям" объявлений функций, например,
# `virtual void foo() = 0` или `~foo() = {default|delete}`.
#
# - 0: Выравнивание по другим присваиваниям (по умолчанию)
# - 1: Выравнивать друг относительно друга, игнорируя обычные присваивания
# - 2: Не выравнивать
#
# Type: unsigned  0  2
# Default: 0
align_assign_decl_func = 2

# Размах для выравнивания по '=' в перечислениях.
#
# 0: не выравнивать (по умолчанию).
#
# Type: unsigned  0  5000
# Default: 0
align_enum_equ_span = 4

# Порог для выравнивания по '=' в перечислениях.
# Для абсолютных порогов используйте отрицательное число.
#
# 0: без ограничений (по умолчанию).
#
# Type: signed  -1000  5000
# Default: 0
align_enum_equ_thresh = 8

# Размах для выравнивания определений членов класса.
#
# 0: не выравнивать (по умолчанию).
#
# Type: unsigned  0  5000
# Default: 0
align_var_class_span = 2

# Порог для выравнивания определений членов класса.
# Для абсолютных порогов используйте отрицательное число.
#
# 0: без ограничений (по умолчанию).
#
# Type: signed  -1000  5000
# Default: 0
align_var_class_thresh = 0

# Зазор для выравнивания определений членов класса.
#
# Type: unsigned  0  16
# Default: 0
align_var_class_gap = 0

# Размах для выравнивания определений членов структуры/объединения.
#
# 0: не выравнивать (по умолчанию).
#
# Type: unsigned  0  5000
# Default: 0
align_var_struct_span = 3

# Порог для выравнивания определений членов структур/объединений.
# Для абсолютных порогов используйте отрицательное число.
#
# 0: без ограничений (по умолчанию).
#
# Type: signed  -1000  5000
# Default: 0
align_var_struct_thresh = 0

# Зазор для выравнивания определения полей структур/объединений.
#
# Type: unsigned  0  16
# Default: 0
align_var_struct_gap = 0

# Размах для выравнивания значений инициализатора структуры.
#
# 0: не выравнивать (по умолчанию).
#
# Type: unsigned  0  5000
# Default: 0
align_struct_init_span = 3

# Размах для выравнивания однострочных typedefs.
#
# 0: не выравнивать (по умолчанию).
#
# Type: unsigned  0  16
# Default: 0
align_typedef_span = 5

# Минимальное расстояние между типом и синонимом в typedef.
#
# Type: unsigned  0  16
# Default: 0
align_typedef_gap = 3

# Как выровнять typedef функции с другими типами.
#
# - 0: Не смешивать их вообще (по умолчанию)
# - 1: Выравнивание открывающей скобки по типам
# - 2: Выравнивание имени типа функции по отношению к другим именам типов
#
# Type: unsigned  0  2
# Default: 0
align_typedef_func = 0

# Как учитывать  '*' при выравнивании typedefs.
#
# - 0: Часть типа typedef, `typedef int *········intref;` (по умолчанию)
# - 1: Часть имени типа: `typedef int········*intref;`
# - 2: Висячий: `typedef int *intref;`
# Висячий: `*` не будет учитываться при выравнивании.
#
# Type: unsigned  0  2
# Default: 0
align_typedef_star_style = 1

# Как учитывать  '&' при выравнивании typedefs.
#
# - 0: Часть типа typedef, `typedef int &········intref;` (по умолчанию)
# - 1: Часть имени типа: `typedef int········&intref`
# - 2: Висячий: `typedef int &intref;`
# Висячий: `&` не будет учитываться при выравнивании.
#
# Type: unsigned  0  2
# Default: 0
align_typedef_amp_style = 0

# Размах для выравнивания комментариев, завершающих строки.
#
# 0: не выравнивать (по умолчанию).
#
# Type: unsigned  0  5000
# Default: 0
align_right_cmt_span = 3

# Минимальное количество колонок между предшествующим текстом и последующим
# комментарием для того. для того, чтобы комментарий был выровнен. Должно быть
# ненулевым, чтобы иметь эффект.
#
# Type: unsigned  0  16
# Default: 0
align_right_cmt_gap = 0

# При выравнивании комментариев, следует ли смешивать комментарии менее чем с
# тремя пробелами с комментариями после '}' и #endif.
#
# Type: true/false
# Default: false
align_right_cmt_mix = false

# Выравнивать только те замыкающие комментарии, которые находятся на одном и том
# же уровне скобки.
#
# Type: true/false
# Default: false
align_right_cmt_same_level = true

# Минимальный столбец, по которому следует выравнивать отстающие комментарии.
# Комментарии, которые выровнены за пределами этого столбца, но которые могут быть
# выровнены в меньшем столбце, могут быть "подтянуты".
#
# 0: игнорировать (по умолчанию).
#
# Type: unsigned  0  200
# Default: 0
align_right_cmt_at_col = 2

# Размах для выравнивания прототипов функций.
#
# 0: не выравнивать (по умолчанию).
#
# Type: unsigned  0  5000
# Default: 0
align_func_proto_span = 0

# Как учитывать `*` при выравнивании прототипов функций.
#
# - 0: Часть типа `long *·····foo();` (по умолчанию)
# - 1: Часть функции `long·····*foo();`
# - 2: Висячий `long *foo();`
# Висячий: '*' не будет учитываться при выравнивании.
#
# Type: unsigned  0  2
# Default: 0
align_func_proto_star_style = 0

# Как учитывать `&` при выравнивании прототипов функций.
#
# - 0: Часть типа `long &·····foo();` (по умолчанию)
# - 1: Часть функции `long·····&foo();`
# - 2: Висячий `long &foo();`
# Висячий: `&` не будет учитываться при выравнивании.
#
# Type: unsigned  0  2
# Default: 0
align_func_proto_amp_style = 0

# Порог для выравнивания прототипов функций.
# Для абсолютных порогов используйте отрицательное число.
#
# 0: без ограничений (по умолчанию).
#
# Type: signed  -1000  5000
# Default: 0
align_func_proto_thresh = 0

# Минимальный зазор между типом возврата и именем функции.
#
# Type: unsigned  0  16
# Default: 0
align_func_proto_gap = 0

# Выравнивать прототипы функций по ключевому слову `operator` вместо того что за
# этим следует.
#
# Type: true/false
# Default: false
align_on_operator = false

# Смешивать выравнивание объявлений прототипов и переменных.
# Если `true`, опции `align_var_def_XXX` используются вместо опций
# `align_func_proto_XXX`.
#
# Type: true/false
# Default: false
align_mix_var_proto = false

# Выравнивать ли однострочные функции по прототипам функций.
# Используется `align_func_proto_span`.
#
# Type: true/false
# Default: false
align_single_line_func = false

# Выравнивать ли открывающую скобку однострочных функций.
# Требуется `align_single_line_func=true`. Используется `align_func_proto_span`.
#
# Type: true/false
# Default: false
align_single_line_brace = false

# Зазор для `align_single_line_brace`.
#
# Type: unsigned  0  16
# Default: 0
align_single_line_brace_gap = 0

# (OC) Размах для выравнивания спецификаций сообщений Objective-C.
#
# 0: не выравнивать (по умолчанию).
#
# Type: unsigned  0  5000
# Default: 0
align_oc_msg_spec_span = 0

# Выравнивать ли макросы, свернутые обратной косой чертой и новой строкой.
# Это будет не будет работать, если макрос содержит многострочный комментарий.
#
# Type: true/false
# Default: false
align_nl_cont = true

# Выравнивать ли макрофункции и переменные вместе.
#
# Type: true/false
# Default: false
align_pp_define_together = false

# Размах для выравнивания тела макросов #define.
#
# - =0: Не выравнивать (по умолчанию)
# - >0: Количество строк (включая комментарии) между блоками
#
# Type: unsigned  0  5000
# Default: 0
align_pp_define_span = 3

# Определяется минимальное расстояние между меткой и значением препроцессора.
#
# Type: unsigned  0  16
# Default: 0
align_pp_define_gap = 4

# Выравнивать строки, начинающиеся с `<<` с предыдущим `<<`
#
# Type: true/false
# Default: true
align_left_shift = true

# Следует ли выравнивать разделенные запятыми утверждения, следующие за `<<` (как
# это используется для инициализации матриц Eigen).
#
# Type: true/false
# Default: false
align_eigen_comma_init = false

# Выравнивать текст после двоеточия `asm volatile ()`
#
# Type: true/false
# Default: false
align_asm_colon = true

# (OC) Размах для выравнивания параметров в вызове сообщения Objective-C по ':'.
#
# 0: не выравнивать (по умолчанию).
#
# Type: unsigned  0  5000
# Default: 0
align_oc_msg_colon_span = 0

# (OC) Всегда выравнивать по первому параметру, даже если он слишком короткий.
#
# Type: true/false
# Default: false
align_oc_msg_colon_first = false

# (OC) Выравнивать параметры в объявлении Objective-C '+' или '-' по ':'.
#
# Type: true/false
# Default: false
align_oc_decl_colon = false

# (OC) Выравнивать параметры в вызове сообщения Objectve-C, если первое двоеточие
# не находится в следующей строке вызова сообщения (так же, как это делает Xcode)
#
# Type: true/false
# Default: false
align_oc_msg_colon_xcode_like = false


################################################################################
# Опции изменения комментариев
################################################################################

# Пытаться сворачивать комментарии на колонке N.
#
# Type: unsigned  0  256
# Default: 0
cmt_width = 0

# Как переформатировать комментарии.
#
# - 0: Без переоформления (кроме сворачивания строки из-за `cmt_width`) (по
# умолчанию)
# - 1: Не трогать вообще
# - 2: Полная перебивка (включите `cmt_indent_multi` для отступа со сверткой
# строки из-за `cmt_width`)
#
# Type: unsigned  0  2
# Default: 0
cmt_reflow_mode = 0

# Путь к файлу, содержащему регулярные выражения, описывающие шаблоны, для которых
# конец одной строки и начало следующей будут складываться в одно предложение или
# абзац во время полного заполнения комментария.
# Регулярные выражения описаны с использованием синтаксиса ECMAScript.
# Синтаксис этой спецификации следующий, где "..." указывает на пользовательское
# регулярное выражение, а "n" указывает на n-ую пару регулярных выражений
# end_of_prev_line_regex и beg_of_next_line_regex:
#
# end_of_prev_line_regex[1] = "...$"
# beg_of_next_line_regex[1] = "^..."
# end_of_prev_line_regex[2] = "...$"
# beg_of_next_line_regex[2] = "^..."
# .
# .
# .
# end_of_prev_line_regex[n] = "...$"
# beg_of_next_line_regex[n] = "^..."
#
# Обратите внимание, что использование этой опции переопределяет стандартное
# сложение регулярных выражений, которые внутренне определяются следующим образом:
#
# end_of_prev_line_regex[1] = "[\w,\]\)]$"
# beg_of_next_line_regex[1] = "^[\w,\[\(]"
# end_of_prev_line_regex[2] = "\.$"
# beg_of_next_line_regex[2] = "^[A-Z]"
#
# Type: string
# Default:
cmt_reflow_fold_regex_file = ""


# Должен ли стартовый отступ свернутых строк соответствовать позиции начала
# несвернутого абзаца комментария (cmt_reflow_mode = 2). Отменяет значение,
# заданное cmt_sp_after_star_cont.
# Фактически абзацный отступ
#
# Обратите внимание, что cmt_align_doxygen_javadoc_tags переопределяет этот
# параметр для абзацев, связанных с тегами javadoc
#
# Type: true/false
# Default: false
cmt_reflow_indent_to_paragraph_start = false

# Преобразовывать все табуляции в пробелы в комментариях. Если false, табуляции в
# в комментариях остаются без изменений, если не используются для отступов.
#
# Type: true/false
# Default: false
cmt_convert_tab_to_spaces = false

# Применять изменения к многострочным комментариям, включая `cmt_width`,
# подстановку ключевых слов и ведущие символы.
#
# Type: true/false
# Default: true
cmt_indent_multi = true

# Выравнивать ли теги в стиле doxygen javadoc (`@param`, `@return` и т.д.) и
# соответствующие поля таким образом, чтобы группы последовательных блочных тегов,
# имена параметров и описания выравниваются друг с другом.
# Отменяет то, что задается параметром `cmt_sp_after_star_cont`. Если `cmt_width >
# 0`, может быть необходимо включить `cmt_indent_multi` и установить
# `cmt_reflow_mode = 2`  чтобы добиться желаемого выравнивания для сворачивания
# строк.
#
# Type: true/false
# Default: false
cmt_align_doxygen_javadoc_tags = false

# Количество пробелов, которые нужно вставить после звезды и перед тегами в стиле
# doxygen javadoc (`@param`, `@return` и т.д.).
# Требуется включить `cmt_align_doxygen_javadoc_tags`. Отменяет значение, заданное
# параметром `cmt_sp_after_star_cont`.
#
# Type: unsigned  0  16
# Default: 1
cmt_sp_before_doxygen_javadoc_tags = 1

# Заменять ли однострочные c-комментарии в конце строки на cpp-комментарии.
#
# Type: true/false
# Default: false
cmt_trailing_single_line_c_to_cpp = false

# Группировать c-комментарии, которые выглядят так, как будто они находятся в
# блоке.
#
# Type: true/false
# Default: false
cmt_c_group = false

# Ставить пустое `/*` в первой строке комбинированного c-комментария.
#
# Type: true/false
# Default: false
cmt_c_nl_start = false

# Добавить новую строку перед закрывающим `*/`.
#
# Type: true/false
# Default: false
cmt_c_nl_end = false

# Заменять cpp-комментарии (//) на c-комментарии(/**/).
#
# Type: true/false
# Default: false
cmt_cpp_to_c = false

# Следует ли группировать cpp-комментарии, которые выглядят так, как будто они
# находятся в блоке. Только имеет смысл, если cmt_cpp_to_c=true.
#
# Type: true/false
# Default: false
cmt_cpp_group = false

# Следует ли помещать пустую строку `/*` в первую строку комбинированного cpp-
# комментария при преобразовании в c-комментарий.
#
# Требуется `cmt_cpp_to_c=true` и `cmt_cpp_group=true`.
#
# Type: true/false
# Default: false
cmt_cpp_nl_start = false

# Добавлять ли новую строку перед закрывающей `*/` комбинированного cpp-
# комментария при преобразовании в c-комментарий.
#
# Требуется `cmt_cpp_to_c=true` и `cmt_cpp_group=true`.
#
# Type: true/false
# Default: false
cmt_cpp_nl_end = false

# Ставить `*` на последующие строки комментариев.
#
# Type: true/false
# Default: false
cmt_star_cont = true

# Количество пробелов для вставки в начале последующих строк комментария.
#
# Type: unsigned  0  16
# Default: 0
cmt_sp_before_star_cont = 0

# Количество пробелов, которое необходимо вставить после * в последующих строках
# комментариев.
#
# Type: unsigned  0  16
# Default: 0
cmt_sp_after_star_cont = 0

# Для многострочных комментариев со знаком '*' удалять лидирующие пробелы, если
# первая и последняя строки комментария имеют одинаковую длину.
#
# Type: true/false
# Default: true
cmt_multi_check_last = true

# Для многострочных комментариев со знаком '*' удалять лидирующие пробелы, если
# первая и последняя строки комментария имеют одинаковую длину И если длина больше
# минимума `first_len`.
#
# Type: unsigned  1  20
# Default: 4
cmt_multi_first_len_minimum = 4

# Путь к файлу, содержащему текст для вставки в начало файла, если файл не
# начинается с комментария на языке Си/Си++. Если вставляемый текст содержит
# `$(filename)`, он будет заменен на имя текущего файла.
#
# Type: string
# Default:
cmt_insert_file_header = ""


# Путь к файлу, содержащему текст для вставки в конец файла, если файл не
# начинается с комментария на языке Си/Си++. Если вставляемый текст содержит
# `$(filename)`, он будет заменен на имя текущего файла.
#
# Type: string
# Default:
cmt_insert_file_footer = ""


# Путь к файлу, содержащему текст для вставки перед определением функции, если
# функция не предваряется комментарием на C/C++.
# Если вставляемый текст содержит `$(function)`, `$(javaparam)` или `$(fclass)`,
# они будут заменены, соответственно, именем функции, javadoc `@param` и `@return`
# или именем класса, к которому принадлежит функция-член.
#
# Type: string
# Default:
cmt_insert_func_header = ""


# Путь к файлу, содержащему текст для вставки перед классом, если классу не
# предшествует комментарий на языке C/C++.
# Если вставляемый текст содержит `$(class)`, он будет заменен на имя класса.
#
# Type: string
# Default:
cmt_insert_class_header = ""


# Путь к файлу, содержащему текст для вставки перед сообщением Objective-C
# спецификации, если методу не предшествует комментарий на языке C/C++.
# Если вставленный текст содержит `$(message)` или `$(javaparam)`, они будут
# заменены, соответственно, на имя функции или javadoc `@param` и `@return`.
#
# Type: string
# Default:
cmt_insert_oc_msg_header = ""


# Вставлять комментарий перед директивой препроцессора, предшествующим функции.
#
# Применяется к `cmt_insert_oc_msg_header`, `cmt_insert_func_header` и
# `cmt_insert_class_header`.
#
# Type: true/false
# Default: false
cmt_insert_before_preproc = false

# Вставлять комментарий, если функция объявлена inline в определении класса.
#
# Применяется к `cmt_insert_func_header`.
#
# Type: true/false
# Default: true
cmt_insert_before_inlines = true

# Вставлять комментарий, если функция является конструктором класса или
# деструктором.
#
# Применяется к `cmt_insert_func_header`.
#
# Type: true/false
# Default: false
cmt_insert_before_ctor_dtor = false


################################################################################
# Опции модификации кода (не пробелы)
################################################################################

# Добавить или убрать фигурные скобки вокруг однострочного блока `do`.
# do{x[i]=y[i];}while(i++<10); // {}
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore
mod_full_brace_do = force

# Добавить или убрать фигурные скобки вокруг однострочного блока `for`.
# for(int i=0;i<10;i++){x[i]=y[i];} // {}
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore
mod_full_brace_for = force

# (Pawn) Добавить или убрать скобки в определении однострочной функции.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore
mod_full_brace_function = ignore

# Добавьте или удалите скобки в однострочном выражении `if`.
# Скобки не будут удаляться, если выражение в скобках содержит `else`.
# if (x<0) {x=-x;} // {}
# if (x<0) {if (y<0) x=y; else x=-x;} // не удаляется
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore
mod_full_brace_if = force

# Следует ли требовать, чтобы все блоки цепочки 'if'/'else if'/'else' либо имели,
# либо не имели скобки.
# Отменяет mod_full_brace_if.
#
# - 0: Не переопределять mod_full_brace_if
# - 1: Добавить скобки во все блоки, если какой-либо блок нуждается в скобках, и
# удалить скобки, если они могут быть удалены из всех блоков.
# - 2: Добавить скобки во все блоки, если в каком-либо блоке уже есть скобки,
# независимо от того, нужны ли они ему.
# - 3: Добавить скобки во все блоки, если любой блок нуждается в скобках, и
# удалить скобки, если они могут быть удалены из всех блоков, за исключением
# случаев, когда все блоки имеют скобки, несмотря на то, что ни один из них в них
# не нуждается.
#
# Type: unsigned  0  3
# Default: 0
mod_full_brace_if_chain = 0

# Добавлять скобки во все блоки цепочки `if`/`else if`/`else`.
# Если `true`, `mod_full_brace_if_chain` будет удалять скобки только из `if`,
# которые не имеет `else if` или `else`.
#
# Type: true/false
# Default: false
mod_full_brace_if_chain_only = false

# Добавить или убрать фигурные скобки вокруг однострочного блока `while`.
# while(i++<10) {a[i]=b[i];}
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore
mod_full_brace_while = force

# (C#) Добавить или убрать фигурные скобки вокруг однострочного блока `using ()`.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore
mod_full_brace_using = ignore

# Не удалять скобки вокруг выражений, которые охватывают N новых строк.
#
# Type: unsigned  0  5000
# Default: 0
mod_full_brace_nl = 5

# Предотвращать удаление скобок из блоков 'if'/'for'/'while'/etc., которые
# охватывают несколько строк.
#
# Применяется к:
# `mod_full_brace_for`,
# `mod_full_brace_if`,
# `mod_full_brace_if_chain`,
# `mod_full_brace_if_chain_only`,
# `mod_full_brace_while`,
# `mod_full_brace_using`
#
# Не влияет:
# `mod_full_brace_do`,
# `mod_full_brace_function`
#
# Type: true/false
# Default: false
mod_full_brace_nl_block_rem_mlcond = false

# Добавить или убрать ненужные круглые скобки на операторе `return`.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore
mod_paren_on_return = add

# (Pawn) Заменять опциональные точки с запятой на настоящие точки с запятой.
#
# Type: true/false
# Default: false
mod_pawn_semicolon = false

# Полностью заключать в круглые скобки булевы выражения в 'while' и 'if' как в `if
# (a && b > c)` => `if (a && (b > c))`.
#
# Type: true/false
# Default: false
mod_full_paren_if_bool = false

# Полностью заключать в круглые скобки булевы выражения после оператора `=`  как в
# `x = a && b &gt; c;` =&gt; `x = (a && (b &gt; c));`
#
# Type: true/false
# Default: false
mod_full_paren_assign_bool = false

# Полностью заключать в круглые скобки булевы выражения после оператора return как
# в `return a && b &gt; c;` =&gt; `return (a && (b &gt; c));`
#
# Type: true/false
# Default: false
mod_full_paren_return_bool = false

# Удалить лишние точки с запятой.
#
# Type: true/false
# Default: false
mod_remove_extra_semicolon = true

# Удалять дублирующие include.
#
# Type: true/false
# Default: false
mod_remove_duplicate_include = false

# Если тело функции превышает указанное количество строк и не имеет комментария
# после закрывающей скобки, то комментарий будет добавлен.
#
# Type: unsigned  0  255
# Default: 0
mod_add_long_function_closebrace_comment = 40

# Если тело пространства имён превышает указанное количество строк и не имеет
# комментария после закрывающей скобки, комментарий будет добавлен.
#
# Type: unsigned  0  255
# Default: 0
mod_add_long_namespace_closebrace_comment = 40

# Если тело класса превышает указанное количество строк и не имеет комментария
# после закрывающей скобки, то комментарий будет добавлен.
#
# Type: unsigned  0  255
# Default: 0
mod_add_long_class_closebrace_comment = 40

# Если тело switch превышает указанное количество строк и не имеет комментария
# после закрывающей скобки, то комментарий будет добавлен.
#
# Type: unsigned  0  255
# Default: 0
mod_add_long_switch_closebrace_comment = 40

# Если тело #ifdef превышает указанное количество строк и не имеет комментария
# после #endif, то комментарий будет добавлен.
#
# Type: unsigned  0  255
# Default: 0
mod_add_long_ifdef_endif_comment = 40
# Если тело #ifdef или #else превышает указанное количество строк и не имеет
# комментария после #else, то комментарий будет добавлен.
#
# Type: unsigned  0  255
# Default: 0
mod_add_long_ifdef_else_comment = 40

# Учитывать регистр в параметрах `mod_sort_xx`.
#
# Type: true/false
# Default: false
mod_sort_case_sensitive = false

# Сортировать последовательные однострочные утверждения `import`.
#
# Type: true/false
# Default: false
mod_sort_import = false

# (C#) Сортировать последовательные однострочные выражения `using`.
#
# Type: true/false
# Default: false
mod_sort_using = false

# Сортировать последовательные однострочные утверждения `#include` (C/C++) и
# `#import' (Objective-C)`.
# Имейте в виду, что это может сломать ваш код, если ваши включения/импорты имеют
# упорядочивающие зависимости.
#
# Type: true/false
# Default: false
mod_sort_include = false

# Приоритезировать утверждения `#include` и `#import`, которые содержат имя файла
# без расширения, при сортировке.
#
# Type: true/false
# Default: false
mod_sort_incl_import_prioritize_filename = false

# Приоритезировать утверждения `#include` и `#import`, которые содержат имя файла
# с расширением, при сортировке.
#
# Type: true/false
# Default: false
mod_sort_incl_import_prioritize_extensionless = false

# Отдавать приоритет утверждениям '#include' и '#import', содержащим <> над
# кавычками, при сортировке.
#
# Type: true/false
# Default: false
mod_sort_incl_import_prioritize_angle_over_quotes = false

# Игнорировать расширение файла в утверждениях `#include` и `#import` при
# сортировке.
#
# Type: true/false
# Default: false
mod_sort_incl_import_ignore_extension = false

# Группировать операторы `#include` и `#import` при включенной сортировке.
#
# Type: true/false
# Default: false
mod_sort_incl_import_grouping_enabled = false

# Перемещать `break`, который появляется после полностью заключенного в скобки
# `case`, перед закрывающей скобкой
# case X: { ... } break;
# ↓↓↓↓
# case X: { ... break; }
#
# Type: true/false
# Default: false
mod_move_case_break = false

# Нужно ли перемещать 'return', который появляется после полностью заключенного в
# скобки 'case' перед закрывающей скобкой, как в `case X: { ... } return;` =&gt;
# `case X: { ... return; }`.
#
# Type: true/false
# Default: false
mod_move_case_return = false

# Добавить или убрать скобки вокруг полностью заключенного в скобки выражения
# case.
# Будет удаляться только в том случае, если в блоке нет объявлений переменных.
# switch(i){
# case 1: { print(i); break;} // удаляется remove
# case 3:  print(i); break;   // добавляется add
# case 2: {int tmp; break;} // никогда не изменяет
# case 4: int tmp; break;   // никогда не изменяет?
# }
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore
mod_case_brace = force

# Удалять ли пустое `return;`, которое появляется в качестве последнего оператора
# в функции.
#
# Type: true/false
# Default: false 
mod_remove_empty_return = false

# Добавить или убрать запятую после последнего значения перечисления.
# enum con{one,two,tre,};
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
mod_enum_last_comma = ignore

# (OC) Упорядочивать свойства.
# Если true, свойства будут упорядочены в соответствии с коэффициентами
# `mod_sort_oc_property_*_weight`.
#
# Type: true/false
# Default: false 
mod_sort_oc_properties = false

# (OC) Вес модификатора свойств класса.
#
# Type: signed
# Default: 0 
mod_sort_oc_property_class_weight = 0

# (OC) Вес 'atomic' и 'nonatomic'.
#
# Type: signed
# Default: 0 
mod_sort_oc_property_thread_safe_weight = 0

# (OC) Вес 'readwrite' при организации свойств.
#
# Type: signed
# Default: 0 
mod_sort_oc_property_readwrite_weight = 0

# (OC) Вес спецификатора типа ссылки ('retain', 'copy', 'assign', 'weak',
# 'strong') при организации свойств.
#
# Type: signed
# Default: 0 
mod_sort_oc_property_reference_weight = 0

# (OC) Вес типа getter ('getter=') при организации свойств.
#
# Type: signed
# Default: 0 
mod_sort_oc_property_getter_weight = 0

# (OC) Вес типа setter ('setter=') при организации свойств.
#
# Type: signed
# Default: 0 
mod_sort_oc_property_setter_weight = 0

# (OC) Вес типа недействительности ('nullable', 'nonnull', 'null_unspecified',
# 'null_resettable') при организации свойств.
#
# Type: signed
# Default: 0 
mod_sort_oc_property_nullability_weight = 0


################################################################################
# Опции препроцессора
################################################################################

# Добавить или убрать отступы директив препроцессора внутри блоков #if на уровне
# скобок 0 (на уровне файла).
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
pp_indent = remove

# Делать отступ #if/#else/#endif на уровне скобок. Если false, то отступ от
# столбца 1.
#
# Type: true/false
# Default: false 
pp_indent_at_level = false

# Делать ли отступ #if/#else/#endif на уровне скобок, если уровень скобок равен 0.
# Если false, то отступы делаются от столбца 1.
#
# Type: true/false
# Default: false 
pp_indent_at_level0 = false

# Указывает количество столбцов для отступа препроцессоров на один уровень на
# уровне скобок 0 (уровень файла).
# Если `pp_indent_at_level=false`, также указывает количество столбцов для отступа
# препроцессоров на уровень на уровне скобок > 0 (уровень функций).
#
# Type: unsigned  0  16
# Default: 1 
pp_indent_count = 1

# Добавить или убрать пробелы после # на основе уровня блоков #if.
#
# Type: ignore / add / remove / force / not_defined
# Default: ignore 
pp_space = remove

# Устанавливает количество пробелов на уровне, добавленных с помощью pp_space.
#
# Type: unsigned  0  16
# Default: 0 
pp_space_count = 0

# Отступ для `#region` и `#endregion` в C# и `#pragma region` в C/C++.
# Отрицательные значения уменьшают отступ до первого столбца.
#
# Type: signed  -16  16
# Default: 0 
pp_indent_region = 0

# Добавить отступ кода между #region и #endregion.
#
# Type: true/false
# Default: false 
pp_region_indent_code = false

# Если `pp_indent_at_level=true`, определяет отступ для #if, #else и #endif, когда
# они не на уровне файла.
# Отрицательные значения уменьшают отступ до первого столбца.
#
# - =0: Отступ препроцессоров с использованием `output_tab_size`
# - >0: Столбец, на уровне которого будут отступать все препроцессоры
#
# Type: signed  -16  16
# Default: 0 
pp_indent_if = 0

# Можно сделать отступ между #if, #else и #endif.
#
# Type: true/false
# Default: false 
pp_if_indent_code = false

# Делать отступ в теле #if, который охватывает весь код в файле.
#
# Type: true/false
# Default: false 
pp_indent_in_guard = false

# Делать отступ `#define` на уровне скобок. Если false, то отступ от столбца 1.
#
# Type: true/false
# Default: false 
pp_define_at_level = false

# Делать отступ `#include` на уровне скобок.
#
# Type: true/false
# Default: false 
pp_include_at_level = false

# Игнорировать тело `#define` во время форматирования.
#
# Type: true/false
# Default: false 
pp_ignore_define_body = false

# Делать отступ для утверждений case между #if, #else и #endif.
# Применяется только к отступу препроцессора, в котором непосредственно внутри
# находятся утверждения case.
#
# Type: true/false
# Default: true 
pp_indent_case = true

# Делать отступ между #if, #else и #endif для целых определений функций.
# Применяется только к отступу препроцессора, в котором непосредственно внутри
# него находится определение функции.
#
# Type: true/false
# Default: true 
pp_indent_func_def = true

# Нужно ли делать отступ для блоков extern C между #if, #else и #endif.
# Применяется только к отступу препроцессора, в котором непосредственно внутри
# него находится блок extern.
#
# Type: true/false
# Default: true 
pp_indent_extern = true

# Как сделать отступ непосредственно внутри #if, #else и #endif.
# Требует `pp_if_indent_code=true` и применяется только к отступу в препроцессоре,
# внутри которого находятся скобки.
# -  0: Без дополнительного отступа
# -  1: Отступ на один уровень
# - -1: Сохранять исходный отступ
#
# Type: signed  -1  1
# Default: 1 
pp_indent_brace = 0

# Выводить ли предупреждающие сообщения для несбалансированных блоков #if и #else.
# Сообщение будет выводиться в следующих случаях:
# - если блок #ifdef заканчивается на другом уровне отступа, чем  с которого он
# начинался.
# Пример:
#
# #ifdef TEST
# int i;
# {
# int j;
# #endif
#
# - блок #elif/#else заканчивается на другом уровне отступа, чем  соответствующий
# блок #ifdef.
# Пример:
#
# #ifdef TEST
# int i;
# #else
# }
# int j;
# #endif
#
# Type: true/false
# Default: false 
pp_warn_unbalanced_if = false


################################################################################
# Опции сортировки включений
################################################################################

# Регекс для категории включений с приоритетом 0.
#
# Type: string
# Default:  
include_category_0 = ""


# Регекс для категории включений с приоритетом 1.
#
# Type: string
# Default:  
include_category_1 = ""


# Регекс для категории включений с приоритетом 2.
#
# Type: string
# Default:  
include_category_2 = ""



################################################################################
# Опции использования
################################################################################

# - true:  использовать `indent_func_call_param` (по умолчанию)
# - false: не использовать `indent_func_call_param`
#
# Type: true/false
# Default: true 
use_indent_func_call_param = true

# Значение отступа для строки продолжения вычисляется по-разному, если утверждение
# является:
# - объявлением: ваш случай с `QString fileName ...`
# - присвоением: ваш случай с `pSettings = new QSettings( ...`
#
# Во втором случае значение отступа может быть использовано дважды:
# - при присваивании
# - при вызове функции (если она присутствует)
#
# Чтобы предотвратить двойное использование значения отступа, используйте этот
# параметр со значением значением `true`.
#
# - true: indent_continue будет использоваться только один раз
# - false: indent_continue будет использоваться каждый раз (по умолчанию)
#
# Требуется indent_ignore_first_continue=false.
#
# Type: true/false
# Default: false 
use_indent_continue_only_once = false

# Отступ может быть:
# - после присваивания, на символе '['
# - в начале тела лямбды
#
# true: отступы будут после присваивания
# false: отступ будет в начале тела лямбды (по умолчанию)
#
# Type: true/false
# Default: false 
indent_cpp_lambda_only_once = false

# Имеет ли `sp_after_angle` приоритет над `sp_inside_fparen`.
# Это было историческим поведением, но, вероятно, не является желаемым, поэтому по
# умолчанию отключено.
#
# Type: true/false
# Default: false 
use_sp_after_angle_always = false

# Применять специальное форматирование для макросов Qt SIGNAL/SLOT.
# По сути, это пытается отформатировать их так, чтобы они соответствовали
# нормализованной форме Qt (т.е. результат QMetaObject::normalizedSignature), что
# может немного улучшить производительность вызова QObject::connect.
#
# Подробности см. в разделе options_for_QT.cpp.
#
# Type: true/false
# Default: true 
use_options_overriding_for_qt_macros = true

# Если `true`: символ подачи формы удаляется из списка пробельных символов.
# См. https://en.cppreference.com/w/cpp/string/byte/isspace.
#
# Type: true/false
# Default: false 
use_form_feed_no_more_as_whitespace_character = false


################################################################################
# Уровень предупреждений - 1: ошибка, 2: предупреждение (default), 3:
# информирование
################################################################################

# (C#) Выдавать предупреждение при замене tab на \t, найденых в строковом литерале
# на C#.
#
# Type: unsigned  1  3
# Default: 2 
warn_level_tabs_found_in_verbatim_string_literals = 2

# Ограничить количество циклов.
# Используется файлом uncrustify.cpp для выхода из бесконечного цикла.
# 0: нет ограничения.
#
# Type: signed
# Default: 0 
debug_max_number_of_loops = 0

# Устанавливает число строк для протокола;
# Используется в функции prot_the_line, если параметр 2 равен нулю.
# 0: не протоколировать.
#
# Type: signed
# Default: 0 
debug_line_number_to_protocol = 0

# Устанавливает количество секунд (секунд) до завершения форматирования текущего
# файла,
# 0: тайм-аут отсутствует.
# только для linux
#
# Type: signed
# Default: 0 
debug_timeout = 0

# Установите количество символов, которые будут напечатаны, если текст слишком
# длинный,
# 0: не усекать.
#
# Type: unsigned  0  960
# Default: 0 
debug_truncate = 0